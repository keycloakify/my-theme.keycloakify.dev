const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/diagnostic-DdYBy5BP.js","assets/main-DiiZGx-8.js","assets/index-CbpMpV_D.js","assets/urlSearchParams-BS7x-Top.js"])))=>i.map(i=>d[i]);
import{D as X,c as mt,a as y,b as Ye,g as Ht,d as wt,e as Ft,t as Jt,f as zt,p as Kt,h as Vt,S as Qt,_ as Te,j as Gt,k as Yt}from"./index-CbpMpV_D.js";import{i as $,c as vt,t as Me,a as Xt,b as nt,g as Zt,O as We}from"./main-DiiZGx-8.js";import{I as se,a as Xe,g as ot}from"./urlSearchParams-BS7x-Top.js";var er={debug:()=>{},info:()=>{},warn:()=>{},error:()=>{}},Q,G,Oe=(t=>(t[t.NONE=0]="NONE",t[t.ERROR=1]="ERROR",t[t.WARN=2]="WARN",t[t.INFO=3]="INFO",t[t.DEBUG=4]="DEBUG",t))(Oe||{});(t=>{function e(){Q=3,G=er}t.reset=e;function r(s){if(!(0<=s&&s<=4))throw new Error("Invalid log level");Q=s}t.setLevel=r;function i(s){G=s}t.setLogger=i})(Oe||(Oe={}));var U=class K{constructor(e){this._name=e}debug(...e){Q>=4&&G.debug(K._format(this._name,this._method),...e)}info(...e){Q>=3&&G.info(K._format(this._name,this._method),...e)}warn(...e){Q>=2&&G.warn(K._format(this._name,this._method),...e)}error(...e){Q>=1&&G.error(K._format(this._name,this._method),...e)}throw(e){throw this.error(e),e}create(e){const r=Object.create(this);return r._method=e,r.debug("begin"),r}static createStatic(e,r){const i=new K(`${e}.${r}`);return i.debug("begin"),i}static _format(e,r){const i=`[${e}]`;return r?`${i} ${r}:`:i}static debug(e,...r){Q>=4&&G.debug(K._format(e),...r)}static info(e,...r){Q>=3&&G.info(K._format(e),...r)}static warn(e,...r){Q>=2&&G.warn(K._format(e),...r)}static error(e,...r){Q>=1&&G.error(K._format(e),...r)}};Oe.reset();var me=class extends Error{};me.prototype.name="InvalidTokenError";function tr(t){return decodeURIComponent(atob(t).replace(/(.)/g,(e,r)=>{let i=r.charCodeAt(0).toString(16).toUpperCase();return i.length<2&&(i="0"+i),"%"+i}))}function rr(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("base64 string is not of the correct length")}try{return tr(e)}catch{return atob(e)}}function ir(t,e){if(typeof t!="string")throw new me("Invalid token specified: must be a string");e||(e={});const r=e.header===!0?0:1,i=t.split(".")[r];if(typeof i!="string")throw new me(`Invalid token specified: missing part #${r+1}`);let s;try{s=rr(i)}catch(o){throw new me(`Invalid token specified: invalid base64 for part #${r+1} (${o.message})`)}try{return JSON.parse(s)}catch(o){throw new me(`Invalid token specified: invalid json for part #${r+1} (${o.message})`)}}var Ce=class{static decode(t){try{return ir(t)}catch(e){throw U.error("JwtUtils.decode",e),e}}static async generateSignedJwt(t,e,r){const i=F.encodeBase64Url(new TextEncoder().encode(JSON.stringify(t))),s=F.encodeBase64Url(new TextEncoder().encode(JSON.stringify(e))),o=`${i}.${s}`,n=await window.crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,new TextEncoder().encode(o)),c=F.encodeBase64Url(new Uint8Array(n));return`${o}.${c}`}},sr="10000000-1000-4000-8000-100000000000",He=t=>btoa([...new Uint8Array(t)].map(e=>String.fromCharCode(e)).join("")),yt=class V{static _randomWord(){const e=new Uint32Array(1);return crypto.getRandomValues(e),e[0]}static generateUUIDv4(){return sr.replace(/[018]/g,r=>(+r^V._randomWord()&15>>+r/4).toString(16)).replace(/-/g,"")}static generateCodeVerifier(){return V.generateUUIDv4()+V.generateUUIDv4()+V.generateUUIDv4()}static async generateCodeChallenge(e){if(!crypto.subtle)throw new Error("Crypto.subtle is available only in secure contexts (HTTPS).");try{const i=new TextEncoder().encode(e),s=await crypto.subtle.digest("SHA-256",i);return He(s).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}catch(r){throw U.error("CryptoUtils.generateCodeChallenge",r),r}}static generateBasicAuth(e,r){const s=new TextEncoder().encode([e,r].join(":"));return He(s)}static async hash(e,r){const i=new TextEncoder().encode(r),s=await crypto.subtle.digest(e,i);return new Uint8Array(s)}static async customCalculateJwkThumbprint(e){let r;switch(e.kty){case"RSA":r={e:e.e,kty:e.kty,n:e.n};break;case"EC":r={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":r={crv:e.crv,kty:e.kty,x:e.x};break;case"oct":r={crv:e.k,kty:e.kty};break;default:throw new Error("Unknown jwk type")}const i=await V.hash("SHA-256",JSON.stringify(r));return V.encodeBase64Url(i)}static async generateDPoPProof({url:e,accessToken:r,httpMethod:i,keyPair:s,nonce:o}){let n,c;const a={jti:window.crypto.randomUUID(),htm:i??"GET",htu:e,iat:Math.floor(Date.now()/1e3)};r&&(n=await V.hash("SHA-256",r),c=V.encodeBase64Url(n),a.ath=c),o&&(a.nonce=o);try{const d=await crypto.subtle.exportKey("jwk",s.publicKey),l={alg:"ES256",typ:"dpop+jwt",jwk:{crv:d.crv,kty:d.kty,x:d.x,y:d.y}};return await Ce.generateSignedJwt(l,a,s.privateKey)}catch(d){throw d instanceof TypeError?new Error(`Error exporting dpop public key: ${d.message}`):d}}static async generateDPoPJkt(e){try{const r=await crypto.subtle.exportKey("jwk",e.publicKey);return await V.customCalculateJwkThumbprint(r)}catch(r){throw r instanceof TypeError?new Error(`Could not retrieve dpop keys from storage: ${r.message}`):r}}static async generateDPoPKeys(){return await window.crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!1,["sign","verify"])}};yt.encodeBase64Url=t=>He(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");var F=yt,ie=class{constructor(t){this._name=t,this._callbacks=[],this._logger=new U(`Event('${this._name}')`)}addHandler(t){return this._callbacks.push(t),()=>this.removeHandler(t)}removeHandler(t){const e=this._callbacks.lastIndexOf(t);e>=0&&this._callbacks.splice(e,1)}async raise(...t){this._logger.debug("raise:",...t);for(const e of this._callbacks)await e(...t)}},at=class{static center({...t}){var e,r,i;return t.width==null&&(t.width=(e=[800,720,600,480].find(s=>s<=window.outerWidth/1.618))!=null?e:360),(r=t.left)!=null||(t.left=Math.max(0,Math.round(window.screenX+(window.outerWidth-t.width)/2))),t.height!=null&&((i=t.top)!=null||(t.top=Math.max(0,Math.round(window.screenY+(window.outerHeight-t.height)/2)))),t}static serialize(t){return Object.entries(t).filter(([,e])=>e!=null).map(([e,r])=>`${e}=${typeof r!="boolean"?r:r?"yes":"no"}`).join(",")}},Y=class Re extends ie{constructor(){super(...arguments),this._logger=new U(`Timer('${this._name}')`),this._timerHandle=null,this._expiration=0,this._callback=()=>{const e=this._expiration-Re.getEpochTime();this._logger.debug("timer completes in",e),this._expiration<=Re.getEpochTime()&&(this.cancel(),super.raise())}}static getEpochTime(){return Math.floor(Date.now()/1e3)}init(e){const r=this._logger.create("init");e=Math.max(Math.floor(e),1);const i=Re.getEpochTime()+e;if(this.expiration===i&&this._timerHandle){r.debug("skipping since already initialized for expiration at",this.expiration);return}this.cancel(),r.debug("using duration",e),this._expiration=i;const s=Math.min(e,5);this._timerHandle=setInterval(this._callback,s*1e3)}get expiration(){return this._expiration}cancel(){this._logger.create("cancel"),this._timerHandle&&(clearInterval(this._timerHandle),this._timerHandle=null)}},Fe=class{static readParams(t,e="query"){if(!t)throw new TypeError("Invalid URL");const i=new URL(t,"http://127.0.0.1")[e==="fragment"?"hash":"search"];return new URLSearchParams(i.slice(1))}},Je=";",ue=class extends Error{constructor(t,e){var r,i,s;if(super(t.error_description||t.error||""),this.form=e,this.name="ErrorResponse",!t.error)throw U.error("ErrorResponse","No error passed"),new Error("No error passed");this.error=t.error,this.error_description=(r=t.error_description)!=null?r:null,this.error_uri=(i=t.error_uri)!=null?i:null,this.state=t.userState,this.session_state=(s=t.session_state)!=null?s:null,this.url_state=t.url_state}},Ze=class extends Error{constructor(t){super(t),this.name="ErrorTimeout"}},nr=class{constructor(t){this._logger=new U("AccessTokenEvents"),this._expiringTimer=new Y("Access token expiring"),this._expiredTimer=new Y("Access token expired"),this._expiringNotificationTimeInSeconds=t.expiringNotificationTimeInSeconds}load(t){const e=this._logger.create("load");if(t.access_token&&t.expires_in!==void 0){const r=t.expires_in;if(e.debug("access token present, remaining duration:",r),r>0){let s=r-this._expiringNotificationTimeInSeconds;s<=0&&(s=1),e.debug("registering expiring timer, raising in",s,"seconds"),this._expiringTimer.init(s)}else e.debug("canceling existing expiring timer because we're past expiration."),this._expiringTimer.cancel();const i=r+1;e.debug("registering expired timer, raising in",i,"seconds"),this._expiredTimer.init(i)}else this._expiringTimer.cancel(),this._expiredTimer.cancel()}unload(){this._logger.debug("unload: canceling existing access token timers"),this._expiringTimer.cancel(),this._expiredTimer.cancel()}addAccessTokenExpiring(t){return this._expiringTimer.addHandler(t)}removeAccessTokenExpiring(t){this._expiringTimer.removeHandler(t)}addAccessTokenExpired(t){return this._expiredTimer.addHandler(t)}removeAccessTokenExpired(t){this._expiredTimer.removeHandler(t)}},or=class{constructor(t,e,r,i,s){this._callback=t,this._client_id=e,this._intervalInSeconds=i,this._stopOnError=s,this._logger=new U("CheckSessionIFrame"),this._timer=null,this._session_state=null,this._message=n=>{n.origin===this._frame_origin&&n.source===this._frame.contentWindow&&(n.data==="error"?(this._logger.error("error message from check session op iframe"),this._stopOnError&&this.stop()):n.data==="changed"?(this._logger.debug("changed message from check session op iframe"),this.stop(),this._callback()):this._logger.debug(n.data+" message from check session op iframe"))};const o=new URL(r);this._frame_origin=o.origin,this._frame=window.document.createElement("iframe"),this._frame.style.visibility="hidden",this._frame.style.position="fixed",this._frame.style.left="-1000px",this._frame.style.top="0",this._frame.width="0",this._frame.height="0",this._frame.src=o.href}load(){return new Promise(t=>{this._frame.onload=()=>{t()},window.document.body.appendChild(this._frame),window.addEventListener("message",this._message,!1)})}start(t){if(this._session_state===t)return;this._logger.create("start"),this.stop(),this._session_state=t;const e=()=>{!this._frame.contentWindow||!this._session_state||this._frame.contentWindow.postMessage(this._client_id+" "+this._session_state,this._frame_origin)};e(),this._timer=setInterval(e,this._intervalInSeconds*1e3)}stop(){this._logger.create("stop"),this._session_state=null,this._timer&&(clearInterval(this._timer),this._timer=null)}},et=class{constructor(){this._logger=new U("InMemoryWebStorage"),this._data={}}clear(){this._logger.create("clear"),this._data={}}getItem(t){return this._logger.create(`getItem('${t}')`),this._data[t]}setItem(t,e){this._logger.create(`setItem('${t}')`),this._data[t]=e}removeItem(t){this._logger.create(`removeItem('${t}')`),delete this._data[t]}get length(){return Object.getOwnPropertyNames(this._data).length}key(t){return Object.getOwnPropertyNames(this._data)[t]}},ze=class extends Error{constructor(t,e){super(e),this.name="ErrorDPoPNonce",this.nonce=t}},tt=class{constructor(t=[],e=null,r={}){this._jwtHandler=e,this._extraHeaders=r,this._logger=new U("JsonService"),this._contentTypes=[],this._contentTypes.push(...t,"application/json"),e&&this._contentTypes.push("application/jwt")}async fetchWithTimeout(t,e={}){const{timeoutInSeconds:r,...i}=e;if(!r)return await fetch(t,i);const s=new AbortController,o=setTimeout(()=>s.abort(),r*1e3);try{return await fetch(t,{...e,signal:s.signal})}catch(n){throw n instanceof DOMException&&n.name==="AbortError"?new Ze("Network timed out"):n}finally{clearTimeout(o)}}async getJson(t,{token:e,credentials:r,timeoutInSeconds:i}={}){const s=this._logger.create("getJson"),o={Accept:this._contentTypes.join(", ")};e&&(s.debug("token passed, setting Authorization header"),o.Authorization="Bearer "+e),this.appendExtraHeaders(o);let n;try{s.debug("url:",t),n=await this.fetchWithTimeout(t,{method:"GET",headers:o,timeoutInSeconds:i,credentials:r})}catch(d){throw s.error("Network Error"),d}s.debug("HTTP response received, status",n.status);const c=n.headers.get("Content-Type");if(c&&!this._contentTypes.find(d=>c.startsWith(d))&&s.throw(new Error(`Invalid response Content-Type: ${c??"undefined"}, from URL: ${t}`)),n.ok&&this._jwtHandler&&c?.startsWith("application/jwt"))return await this._jwtHandler(await n.text());let a;try{a=await n.json()}catch(d){throw s.error("Error parsing JSON response",d),n.ok?d:new Error(`${n.statusText} (${n.status})`)}if(!n.ok)throw s.error("Error from server:",a),a.error?new ue(a):new Error(`${n.statusText} (${n.status}): ${JSON.stringify(a)}`);return a}async postForm(t,{body:e,basicAuth:r,timeoutInSeconds:i,initCredentials:s,extraHeaders:o}){const n=this._logger.create("postForm"),c={Accept:this._contentTypes.join(", "),"Content-Type":"application/x-www-form-urlencoded",...o};r!==void 0&&(c.Authorization="Basic "+r),this.appendExtraHeaders(c);let a;try{n.debug("url:",t),a=await this.fetchWithTimeout(t,{method:"POST",headers:c,body:e,timeoutInSeconds:i,credentials:s})}catch(g){throw n.error("Network error"),g}n.debug("HTTP response received, status",a.status);const d=a.headers.get("Content-Type");if(d&&!this._contentTypes.find(g=>d.startsWith(g)))throw new Error(`Invalid response Content-Type: ${d??"undefined"}, from URL: ${t}`);const l=await a.text();let u={};if(l)try{u=JSON.parse(l)}catch(g){throw n.error("Error parsing JSON response",g),a.ok?g:new Error(`${a.statusText} (${a.status})`)}if(!a.ok){if(n.error("Error from server:",u),a.headers.has("dpop-nonce")){const g=a.headers.get("dpop-nonce");throw new ze(g,`${JSON.stringify(u)}`)}throw u.error?new ue(u,e):new Error(`${a.statusText} (${a.status}): ${JSON.stringify(u)}`)}return u}appendExtraHeaders(t){const e=this._logger.create("appendExtraHeaders"),r=Object.keys(this._extraHeaders),i=["authorization","accept","content-type"];r.length!==0&&r.forEach(s=>{if(i.includes(s.toLocaleLowerCase())){e.warn("Protected header could not be overridden",s,i);return}const o=typeof this._extraHeaders[s]=="function"?this._extraHeaders[s]():this._extraHeaders[s];o&&o!==""&&(t[s]=o)})}},ar=class{constructor(t){this._settings=t,this._logger=new U("MetadataService"),this._signingKeys=null,this._metadata=null,this._metadataUrl=this._settings.metadataUrl,this._jsonService=new tt(["application/jwk-set+json"],null,this._settings.extraHeaders),this._settings.signingKeys&&(this._logger.debug("using signingKeys from settings"),this._signingKeys=this._settings.signingKeys),this._settings.metadata&&(this._logger.debug("using metadata from settings"),this._metadata=this._settings.metadata),this._settings.fetchRequestCredentials&&(this._logger.debug("using fetchRequestCredentials from settings"),this._fetchRequestCredentials=this._settings.fetchRequestCredentials)}resetSigningKeys(){this._signingKeys=null}async getMetadata(){const t=this._logger.create("getMetadata");if(this._metadata)return t.debug("using cached values"),this._metadata;if(!this._metadataUrl)throw t.throw(new Error("No authority or metadataUrl configured on settings")),null;t.debug("getting metadata from",this._metadataUrl);const e=await this._jsonService.getJson(this._metadataUrl,{credentials:this._fetchRequestCredentials,timeoutInSeconds:this._settings.requestTimeoutInSeconds});return t.debug("merging remote JSON with seed metadata"),this._metadata=Object.assign({},this._settings.metadataSeed,e),this._metadata}getIssuer(){return this._getMetadataProperty("issuer")}getAuthorizationEndpoint(){return this._getMetadataProperty("authorization_endpoint")}getUserInfoEndpoint(){return this._getMetadataProperty("userinfo_endpoint")}getTokenEndpoint(t=!0){return this._getMetadataProperty("token_endpoint",t)}getCheckSessionIframe(){return this._getMetadataProperty("check_session_iframe",!0)}getEndSessionEndpoint(){return this._getMetadataProperty("end_session_endpoint",!0)}getRevocationEndpoint(t=!0){return this._getMetadataProperty("revocation_endpoint",t)}getKeysEndpoint(t=!0){return this._getMetadataProperty("jwks_uri",t)}async _getMetadataProperty(t,e=!1){const r=this._logger.create(`_getMetadataProperty('${t}')`),i=await this.getMetadata();if(r.debug("resolved"),i[t]===void 0){if(e===!0){r.warn("Metadata does not contain optional property");return}r.throw(new Error("Metadata does not contain property "+t))}return i[t]}async getSigningKeys(){const t=this._logger.create("getSigningKeys");if(this._signingKeys)return t.debug("returning signingKeys from cache"),this._signingKeys;const e=await this.getKeysEndpoint(!1);t.debug("got jwks_uri",e);const r=await this._jsonService.getJson(e,{timeoutInSeconds:this._settings.requestTimeoutInSeconds});if(t.debug("got key set",r),!Array.isArray(r.keys))throw t.throw(new Error("Missing keys on keyset")),null;return this._signingKeys=r.keys,this._signingKeys}},Ae=class{constructor({prefix:t="oidc.",store:e=localStorage}={}){this._logger=new U("WebStorageStateStore"),this._store=e,this._prefix=t}async set(t,e){this._logger.create(`set('${t}')`),t=this._prefix+t,await this._store.setItem(t,e)}async get(t){return this._logger.create(`get('${t}')`),t=this._prefix+t,await this._store.getItem(t)}async remove(t){this._logger.create(`remove('${t}')`),t=this._prefix+t;const e=await this._store.getItem(t);return await this._store.removeItem(t),e}async getAllKeys(){this._logger.create("getAllKeys");const t=await this._store.length,e=[];for(let r=0;r<t;r++){const i=await this._store.key(r);i&&i.indexOf(this._prefix)===0&&e.push(i.substr(this._prefix.length))}return e}},cr="code",dr="openid",lr="client_secret_post",ur=900,Ke=class{constructor({stateUrlParamValue:t,authority:e,metadataUrl:r,metadata:i,signingKeys:s,metadataSeed:o,client_id:n,client_secret:c,response_type:a=cr,scope:d=dr,redirect_uri:l,post_logout_redirect_uri:u,client_authentication:g=lr,prompt:S,display:f,max_age:h,ui_locales:p,acr_values:x,resource:k,response_mode:_,filterProtocolClaims:q=!0,loadUserInfo:B=!1,requestTimeoutInSeconds:N,staleStateAgeInSeconds:E=ur,mergeClaimsStrategy:b={array:"replace"},disablePKCE:A=!1,stateStore:L,revokeTokenAdditionalContentTypes:D,fetchRequestCredentials:z,refreshTokenAllowedScope:ne,extraQueryParams:Z={},extraTokenParams:j={},extraHeaders:ee={},dpop:R,omitScopeWhenRequesting:fe=!1}){var he;if(this.stateUrlParamValue=t,this.authority=e,r?this.metadataUrl=r:(this.metadataUrl=e,e&&(this.metadataUrl.endsWith("/")||(this.metadataUrl+="/"),this.metadataUrl+=".well-known/openid-configuration")),this.metadata=i,this.metadataSeed=o,this.signingKeys=s,this.client_id=n,this.client_secret=c,this.response_type=a,this.scope=d,this.redirect_uri=l,this.post_logout_redirect_uri=u,this.client_authentication=g,this.prompt=S,this.display=f,this.max_age=h,this.ui_locales=p,this.acr_values=x,this.resource=k,this.response_mode=_,this.filterProtocolClaims=q??!0,this.loadUserInfo=!!B,this.staleStateAgeInSeconds=E,this.mergeClaimsStrategy=b,this.omitScopeWhenRequesting=fe,this.disablePKCE=!!A,this.revokeTokenAdditionalContentTypes=D,this.fetchRequestCredentials=z||"same-origin",this.requestTimeoutInSeconds=N,L)this.stateStore=L;else{const te=typeof window<"u"?window.localStorage:new et;this.stateStore=new Ae({store:te})}if(this.refreshTokenAllowedScope=ne,this.extraQueryParams=Z,this.extraTokenParams=j,this.extraHeaders=ee,this.dpop=R,this.dpop&&!((he=this.dpop)!=null&&he.store))throw new Error("A DPoPStore is required when dpop is enabled")}},hr=class{constructor(t,e){this._settings=t,this._metadataService=e,this._logger=new U("UserInfoService"),this._getClaimsFromJwt=async r=>{const i=this._logger.create("_getClaimsFromJwt");try{const s=Ce.decode(r);return i.debug("JWT decoding successful"),s}catch(s){throw i.error("Error parsing JWT response"),s}},this._jsonService=new tt(void 0,this._getClaimsFromJwt,this._settings.extraHeaders)}async getClaims(t){const e=this._logger.create("getClaims");t||this._logger.throw(new Error("No token passed"));const r=await this._metadataService.getUserInfoEndpoint();e.debug("got userinfo url",r);const i=await this._jsonService.getJson(r,{token:t,credentials:this._settings.fetchRequestCredentials,timeoutInSeconds:this._settings.requestTimeoutInSeconds});return e.debug("got claims",i),i}},ge=new WeakMap,St=class{constructor(t,e){this._settings=t,this._metadataService=e,this._logger=new U("TokenClient"),this._jsonService=new tt(this._settings.revokeTokenAdditionalContentTypes,null,this._settings.extraHeaders)}async exchangeCode({grant_type:t="authorization_code",redirect_uri:e=this._settings.redirect_uri,client_id:r=this._settings.client_id,client_secret:i=this._settings.client_secret,extraHeaders:s,...o}){const n=this._logger.create("exchangeCode");r||n.throw(new Error("A client_id is required")),e||n.throw(new Error("A redirect_uri is required")),o.code||n.throw(new Error("A code is required"));const c=new URLSearchParams({grant_type:t,redirect_uri:e});for(const[S,f]of Object.entries(o))f!=null&&c.set(S,f);let a;switch(this._settings.client_authentication){case"client_secret_basic":if(!i)throw n.throw(new Error("A client_secret is required")),null;a=F.generateBasicAuth(r,i);break;case"client_secret_post":c.append("client_id",r),i&&c.append("client_secret",i);break}const d=await this._metadataService.getTokenEndpoint(!1);n.debug("got token endpoint");const l=Date.now(),u=await this._jsonService.postForm(d,{body:c,basicAuth:a,timeoutInSeconds:this._settings.requestTimeoutInSeconds,initCredentials:this._settings.fetchRequestCredentials,extraHeaders:s}),g=Date.now();return ge.set(u,Math.floor((l+g)/2)),n.debug("got response"),u}async exchangeCredentials({grant_type:t="password",client_id:e=this._settings.client_id,client_secret:r=this._settings.client_secret,scope:i=this._settings.scope,...s}){const o=this._logger.create("exchangeCredentials");e||o.throw(new Error("A client_id is required"));const n=new URLSearchParams({grant_type:t});this._settings.omitScopeWhenRequesting||n.set("scope",i);for(const[g,S]of Object.entries(s))S!=null&&n.set(g,S);let c;switch(this._settings.client_authentication){case"client_secret_basic":if(!r)throw o.throw(new Error("A client_secret is required")),null;c=F.generateBasicAuth(e,r);break;case"client_secret_post":n.append("client_id",e),r&&n.append("client_secret",r);break}const a=await this._metadataService.getTokenEndpoint(!1);o.debug("got token endpoint");const d=Date.now(),l=await this._jsonService.postForm(a,{body:n,basicAuth:c,timeoutInSeconds:this._settings.requestTimeoutInSeconds,initCredentials:this._settings.fetchRequestCredentials}),u=Date.now();return ge.set(l,Math.floor((d+u)/2)),o.debug("got response"),l}async exchangeRefreshToken({grant_type:t="refresh_token",client_id:e=this._settings.client_id,client_secret:r=this._settings.client_secret,timeoutInSeconds:i,extraHeaders:s,...o}){const n=this._logger.create("exchangeRefreshToken");e||n.throw(new Error("A client_id is required")),o.refresh_token||n.throw(new Error("A refresh_token is required"));const c=new URLSearchParams({grant_type:t});for(const[S,f]of Object.entries(o))Array.isArray(f)?f.forEach(h=>c.append(S,h)):f!=null&&c.set(S,f);let a;switch(this._settings.client_authentication){case"client_secret_basic":if(!r)throw n.throw(new Error("A client_secret is required")),null;a=F.generateBasicAuth(e,r);break;case"client_secret_post":c.append("client_id",e),r&&c.append("client_secret",r);break}const d=await this._metadataService.getTokenEndpoint(!1);n.debug("got token endpoint");const l=Date.now(),u=await this._jsonService.postForm(d,{body:c,basicAuth:a,timeoutInSeconds:i,initCredentials:this._settings.fetchRequestCredentials,extraHeaders:s}),g=Date.now();return ge.set(u,Math.floor((l+g)/2)),n.debug("got response"),u}async revoke(t){var e;const r=this._logger.create("revoke");t.token||r.throw(new Error("A token is required"));const i=await this._metadataService.getRevocationEndpoint(!1);r.debug(`got revocation endpoint, revoking ${(e=t.token_type_hint)!=null?e:"default token type"}`);const s=new URLSearchParams;for(const[o,n]of Object.entries(t))n!=null&&s.set(o,n);s.set("client_id",this._settings.client_id),this._settings.client_secret&&s.set("client_secret",this._settings.client_secret),await this._jsonService.postForm(i,{body:s,timeoutInSeconds:this._settings.requestTimeoutInSeconds}),r.debug("got response")}},gr=class{constructor(t,e,r){this._settings=t,this._metadataService=e,this._claimsService=r,this._logger=new U("ResponseValidator"),this._userInfoService=new hr(this._settings,this._metadataService),this._tokenClient=new St(this._settings,this._metadataService)}async validateSigninResponse(t,e,r){const i=this._logger.create("validateSigninResponse");this._processSigninState(t,e),i.debug("state processed"),await this._processCode(t,e,r),i.debug("code processed"),t.isOpenId&&this._validateIdTokenAttributes(t),i.debug("tokens validated"),await this._processClaims(t,e?.skipUserInfo,t.isOpenId),i.debug("claims processed")}async validateCredentialsResponse(t,e){const r=this._logger.create("validateCredentialsResponse");t.isOpenId&&t.id_token&&this._validateIdTokenAttributes(t),r.debug("tokens validated"),await this._processClaims(t,e,t.isOpenId),r.debug("claims processed")}async validateRefreshResponse(t,e){var r,i;const s=this._logger.create("validateRefreshResponse");t.userState=e.data,(r=t.session_state)!=null||(t.session_state=e.session_state),(i=t.scope)!=null||(t.scope=e.scope),t.isOpenId&&t.id_token&&(this._validateIdTokenAttributes(t,e.id_token),s.debug("ID Token validated")),t.id_token||(t.id_token=e.id_token,t.profile=e.profile);const o=t.isOpenId&&!!t.id_token;await this._processClaims(t,!1,o),s.debug("claims processed")}validateSignoutResponse(t,e){const r=this._logger.create("validateSignoutResponse");if(e.id!==t.state&&r.throw(new Error("State does not match")),r.debug("state validated"),t.userState=e.data,t.error)throw r.warn("Response was error",t.error),new ue(t)}_processSigninState(t,e){var r;const i=this._logger.create("_processSigninState");if(e.id!==t.state&&i.throw(new Error("State does not match")),e.client_id||i.throw(new Error("No client_id on state")),e.authority||i.throw(new Error("No authority on state")),this._settings.authority!==e.authority&&i.throw(new Error("authority mismatch on settings vs. signin state")),this._settings.client_id&&this._settings.client_id!==e.client_id&&i.throw(new Error("client_id mismatch on settings vs. signin state")),i.debug("state validated"),t.userState=e.data,t.url_state=e.url_state,(r=t.scope)!=null||(t.scope=e.scope),t.error)throw i.warn("Response was error",t.error),new ue(t);e.code_verifier&&!t.code&&i.throw(new Error("Expected code in response"))}async _processClaims(t,e=!1,r=!0){const i=this._logger.create("_processClaims");if(t.profile=this._claimsService.filterProtocolClaims(t.profile),e||!this._settings.loadUserInfo||!t.access_token){i.debug("not loading user info");return}i.debug("loading user info");const s=await this._userInfoService.getClaims(t.access_token);i.debug("user info claims received from user info endpoint"),r&&s.sub!==t.profile.sub&&i.throw(new Error("subject from UserInfo response does not match subject in ID Token")),t.profile=this._claimsService.mergeClaims(t.profile,this._claimsService.filterProtocolClaims(s)),i.debug("user info claims received, updated profile:",t.profile)}async _processCode(t,e,r){const i=this._logger.create("_processCode");if(t.code){i.debug("Validating code");const s=await this._tokenClient.exchangeCode({client_id:e.client_id,client_secret:e.client_secret,code:t.code,redirect_uri:e.redirect_uri,code_verifier:e.code_verifier,extraHeaders:r,...e.extraTokenParams});Object.assign(t,s),t.__oidc_spa_tokenResponse=s,t.__oidc_spa_localTimeWhenTokenIssued=(()=>{const o=ge.get(s);if(o===void 0)throw new Error("oidc-spa error in oidc-client-ts");return o})()}else i.debug("No code to process")}_validateIdTokenAttributes(t,e){var r;const i=this._logger.create("_validateIdTokenAttributes");i.debug("decoding ID Token JWT");const s=Ce.decode((r=t.id_token)!=null?r:"");if(s.sub||i.throw(new Error("ID Token is missing a subject claim")),e){const o=Ce.decode(e);s.sub!==o.sub&&i.throw(new Error("sub in id_token does not match current sub")),s.auth_time&&s.auth_time!==o.auth_time&&i.throw(new Error("auth_time in id_token does not match original auth_time")),s.azp&&s.azp!==o.azp&&i.throw(new Error("azp in id_token does not match original azp")),!s.azp&&o.azp&&i.throw(new Error("azp not in id_token, but present in original id_token"))}t.profile=s}},Ne=class Ve{constructor(e){var r;this.id=(r=e.id)!=null?r:(()=>{const{stateUrlParamValue:i}=e;if(i===void 0)throw console.error("Error in oidc-spa patch for oidc-client-ts: stateUrlParamValue is required"),new Error("Error in oidc-spa patch for oidc-client-ts: stateUrlParamValue is required");return i})(),this.data=e.data,e.created&&e.created>0?this.created=e.created:this.created=Y.getEpochTime(),this.request_type=e.request_type,this.url_state=e.url_state}toStorageString(){return new U("State").create("toStorageString"),JSON.stringify({id:this.id,data:this.data,created:this.created,request_type:this.request_type,url_state:this.url_state})}static fromStorageString(e){return U.createStatic("State","fromStorageString"),Promise.resolve(new Ve(JSON.parse(e)))}static async clearStaleState(e,r){const i=U.createStatic("State","clearStaleState"),s=Y.getEpochTime()-r,o=await e.getAllKeys();i.debug("got keys",o);for(let n=0;n<o.length;n++){const c=o[n],a=await e.get(c);let d=!1;if(a)try{const l=await Ve.fromStorageString(a);i.debug("got item from key:",c,l.created),l.created<=s&&(d=!0)}catch(l){i.error("Error parsing state for key:",c,l),d=!0}else i.debug("no item in storage for key:",c),d=!0;d&&(i.debug("removed item for key:",c),e.remove(c))}}},kt=class Qe extends Ne{constructor(e){super(e),this.code_verifier=e.code_verifier,this.code_challenge=e.code_challenge,this.authority=e.authority,this.client_id=e.client_id,this.redirect_uri=e.redirect_uri,this.scope=e.scope,this.client_secret=e.client_secret,this.extraTokenParams=e.extraTokenParams,this.response_mode=e.response_mode,this.skipUserInfo=e.skipUserInfo}static async create(e){const r=e.code_verifier===!0?F.generateCodeVerifier():e.code_verifier||void 0,i=r?await F.generateCodeChallenge(r):void 0;return new Qe({...e,code_verifier:r,code_challenge:i})}toStorageString(){return new U("SigninState").create("toStorageString"),JSON.stringify({id:this.id,data:this.data,created:this.created,request_type:this.request_type,url_state:this.url_state,code_verifier:this.code_verifier,authority:this.authority,client_id:this.client_id,redirect_uri:this.redirect_uri,scope:this.scope,client_secret:this.client_secret,extraTokenParams:this.extraTokenParams,response_mode:this.response_mode,skipUserInfo:this.skipUserInfo})}static fromStorageString(e){U.createStatic("SigninState","fromStorageString");const r=JSON.parse(e);return Qe.create(r)}},bt=class Tt{constructor(e){this.url=e.url,this.state=e.state}static async create({stateUrlParamValue:e,url:r,authority:i,client_id:s,redirect_uri:o,response_type:n,scope:c,state_data:a,response_mode:d,request_type:l,client_secret:u,nonce:g,url_state:S,resource:f,skipUserInfo:h,extraQueryParams:p,extraTokenParams:x,disablePKCE:k,dpopJkt:_,omitScopeWhenRequesting:q,transformUrl:B,...N}){if(!r)throw this._logger.error("create: No url passed"),new Error("url");if(!s)throw this._logger.error("create: No client_id passed"),new Error("client_id");if(!o)throw this._logger.error("create: No redirect_uri passed"),new Error("redirect_uri");if(!n)throw this._logger.error("create: No response_type passed"),new Error("response_type");if(!c)throw this._logger.error("create: No scope passed"),new Error("scope");if(!i)throw this._logger.error("create: No authority passed"),new Error("authority");const E=await kt.create({stateUrlParamValue:e,data:a,request_type:l,url_state:S,code_verifier:!k,client_id:s,authority:i,redirect_uri:o,response_mode:d,client_secret:u,scope:c,extraTokenParams:x,skipUserInfo:h}),b=new URL(r);b.searchParams.append("client_id",s),b.searchParams.append("redirect_uri",o),b.searchParams.append("response_type",n),q||b.searchParams.append("scope",c),g&&b.searchParams.append("nonce",g),_&&b.searchParams.append("dpop_jkt",_);let A=E.id;S&&(A=`${A}${Je}${S}`),b.searchParams.append("state",A),E.code_challenge&&(b.searchParams.append("code_challenge",E.code_challenge),b.searchParams.append("code_challenge_method","S256")),f&&(Array.isArray(f)?f:[f]).forEach(D=>b.searchParams.append("resource",D));for(const[L,D]of Object.entries({response_mode:d,...N,...p}))D!=null&&b.searchParams.append(L,D.toString());return new Tt({url:B(b.href),state:E})}};bt._logger=new U("SigninRequest");var fr=bt,pr="openid",$e=class{constructor(t){if(this.access_token="",this.token_type="",this.profile={},this.state=t.get("state"),this.session_state=t.get("session_state"),this.state){const e=decodeURIComponent(this.state).split(Je);this.state=e[0],e.length>1&&(this.url_state=e.slice(1).join(Je))}this.error=t.get("error"),this.error_description=t.get("error_description"),this.error_uri=t.get("error_uri"),this.code=t.get("code"),this.__oidc_spa_tokenResponse=void 0,this.__oidc_spa_localTimeWhenTokenIssued=void 0}get expires_in(){if(this.expires_at!==void 0)return this.expires_at-Y.getEpochTime()}set expires_in(t){typeof t=="string"&&(t=Number(t)),t!==void 0&&t>=0&&(this.expires_at=Math.floor(t)+Y.getEpochTime())}get isOpenId(){var t;return((t=this.scope)==null?void 0:t.split(" ").includes(pr))||!!this.id_token}},_r=class{constructor({url:t,stateUrlParamValue:e,state_data:r,id_token_hint:i,post_logout_redirect_uri:s,extraQueryParams:o,request_type:n,client_id:c}){if(this._logger=new U("SignoutRequest"),!t)throw this._logger.error("ctor: No url passed"),new Error("url");const a=new URL(t);i&&a.searchParams.append("id_token_hint",i),c&&a.searchParams.append("client_id",c),s&&(a.searchParams.append("post_logout_redirect_uri",s),r&&(this.state=new Ne({stateUrlParamValue:e,data:r,request_type:n}),a.searchParams.append("state",this.state.id)));for(const[d,l]of Object.entries({...o}))l!=null&&a.searchParams.append(d,l.toString());this.url=a.href}},mr=class{constructor(t){this.state=t.get("state"),this.error=t.get("error"),this.error_description=t.get("error_description"),this.error_uri=t.get("error_uri")}},wr=["nbf","jti","auth_time","nonce","acr","amr","azp","at_hash"],vr=["sub","iss","aud","exp","iat"],yr=class{constructor(t){this._settings=t,this._logger=new U("ClaimsService")}filterProtocolClaims(t){const e={...t};if(this._settings.filterProtocolClaims){let r;Array.isArray(this._settings.filterProtocolClaims)?r=this._settings.filterProtocolClaims:r=wr;for(const i of r)vr.includes(i)||delete e[i]}return e}mergeClaims(t,e){const r={...t};for(const[i,s]of Object.entries(e))if(r[i]!==s)if(Array.isArray(r[i])||Array.isArray(s))if(this._settings.mergeClaimsStrategy.array=="replace")r[i]=s;else{const o=Array.isArray(r[i])?r[i]:[r[i]];for(const n of Array.isArray(s)?s:[s])o.includes(n)||o.push(n);r[i]=o}else typeof r[i]=="object"&&typeof s=="object"?r[i]=this.mergeClaims(r[i],s):r[i]=s;return r}},It=class{constructor(t,e){this.keys=t,this.nonce=e}},Sr=class{constructor(t,e){this._logger=new U("OidcClient"),this._stateUrlParamValue=t.stateUrlParamValue,this.settings=t instanceof Ke?t:new Ke(t),this.metadataService=e??new ar(this.settings),this._claimsService=new yr(this.settings),this._validator=new gr(this.settings,this.metadataService,this._claimsService),this._tokenClient=new St(this.settings,this.metadataService)}async createSigninRequest({state:t,request:e,request_uri:r,request_type:i,id_token_hint:s,login_hint:o,skipUserInfo:n,nonce:c,url_state:a,response_type:d=this.settings.response_type,scope:l=this.settings.scope,redirect_uri:u=this.settings.redirect_uri,prompt:g=this.settings.prompt,display:S=this.settings.display,max_age:f=this.settings.max_age,ui_locales:h=this.settings.ui_locales,acr_values:p=this.settings.acr_values,resource:x=this.settings.resource,response_mode:k=this.settings.response_mode,extraQueryParams:_=this.settings.extraQueryParams,extraTokenParams:q=this.settings.extraTokenParams,dpopJkt:B,omitScopeWhenRequesting:N=this.settings.omitScopeWhenRequesting,transformUrl:E}){const b=this._logger.create("createSigninRequest");if(d!=="code")throw new Error("Only the Authorization Code flow (with PKCE) is supported");const A=await this.metadataService.getAuthorizationEndpoint();b.debug("Received authorization endpoint",A);const L=await fr.create({stateUrlParamValue:this._stateUrlParamValue,url:A,authority:this.settings.authority,client_id:this.settings.client_id,redirect_uri:u,response_type:d,scope:l,state_data:t,url_state:a,prompt:g,display:S,max_age:f,ui_locales:h,id_token_hint:s,login_hint:o,acr_values:p,dpopJkt:B,resource:x,request:e,request_uri:r,extraQueryParams:_,extraTokenParams:q,request_type:i,response_mode:k,client_secret:this.settings.client_secret,skipUserInfo:n,nonce:c,disablePKCE:this.settings.disablePKCE,omitScopeWhenRequesting:N,transformUrl:E});await this.clearStaleState();const D=L.state;return await this.settings.stateStore.set(D.id,D.toStorageString()),L}async readSigninResponseState(t,e=!1){const r=this._logger.create("readSigninResponseState"),i=new $e(Fe.readParams(t,this.settings.response_mode));if(!i.state)throw r.throw(new Error("No state in response")),null;const s=await this.settings.stateStore[e?"remove":"get"](i.state);if(!s)throw r.throw(new Error("No matching state found in storage")),null;return{state:await kt.fromStorageString(s),response:i}}async processSigninResponse(t,e){const r=this._logger.create("processSigninResponse"),{state:i,response:s}=await this.readSigninResponseState(t,!0);if(r.debug("received state from storage; validating response"),this.settings.dpop&&this.settings.dpop.store){const o=await this.getDpopProof(this.settings.dpop.store);e={...e,DPoP:o}}try{await this._validator.validateSigninResponse(s,i,e)}catch(o){if(o instanceof ze&&this.settings.dpop){const n=await this.getDpopProof(this.settings.dpop.store,o.nonce);e.DPoP=n,await this._validator.validateSigninResponse(s,i,e)}else throw o}return s}async getDpopProof(t,e){let r,i;return(await t.getAllKeys()).includes(this.settings.client_id)?(i=await t.get(this.settings.client_id),i.nonce!==e&&e&&(i.nonce=e,await t.set(this.settings.client_id,i))):(r=await F.generateDPoPKeys(),i=new It(r,e),await t.set(this.settings.client_id,i)),await F.generateDPoPProof({url:await this.metadataService.getTokenEndpoint(!1),httpMethod:"POST",keyPair:i.keys,nonce:i.nonce})}async processResourceOwnerPasswordCredentials({username:t,password:e,skipUserInfo:r=!1,extraTokenParams:i={}}){const s=await this._tokenClient.exchangeCredentials({username:t,password:e,...i}),o=new $e(new URLSearchParams);return Object.assign(o,s),o.__oidc_spa_tokenResponse=s,o.__oidc_spa_localTimeWhenTokenIssued=(()=>{const n=ge.get(s);if(n===void 0)throw new Error("oidc-spa error in oidc-client-ts");return n})(),await this._validator.validateCredentialsResponse(o,r),o}async useRefreshToken({state:t,redirect_uri:e,resource:r,timeoutInSeconds:i,extraHeaders:s,extraTokenParams:o}){var n;const c=this._logger.create("useRefreshToken");let a;if(this.settings.refreshTokenAllowedScope===void 0)a=t.scope;else{const u=this.settings.refreshTokenAllowedScope.split(" ");a=(((n=t.scope)==null?void 0:n.split(" "))||[]).filter(S=>u.includes(S)).join(" ")}if(this.settings.dpop&&this.settings.dpop.store){const u=await this.getDpopProof(this.settings.dpop.store);s={...s,DPoP:u}}let d;try{d=await this._tokenClient.exchangeRefreshToken({refresh_token:t.refresh_token,scope:a,redirect_uri:e,resource:r,timeoutInSeconds:i,extraHeaders:s,...o})}catch(u){if(u instanceof ze&&this.settings.dpop)s.DPoP=await this.getDpopProof(this.settings.dpop.store,u.nonce),d=await this._tokenClient.exchangeRefreshToken({refresh_token:t.refresh_token,scope:a,redirect_uri:e,resource:r,timeoutInSeconds:i,extraHeaders:s,...o});else throw u}const l=new $e(new URLSearchParams);return Object.assign(l,d),l.__oidc_spa_tokenResponse=d,l.__oidc_spa_localTimeWhenTokenIssued=(()=>{const u=ge.get(d);if(u===void 0)throw new Error("oidc-spa error in oidc-client-ts");return u})(),c.debug("validating response",l),await this._validator.validateRefreshResponse(l,{...t,scope:a}),l}async createSignoutRequest({state:t,id_token_hint:e,client_id:r,request_type:i,post_logout_redirect_uri:s=this.settings.post_logout_redirect_uri,extraQueryParams:o=this.settings.extraQueryParams}){const n=this._logger.create("createSignoutRequest"),c=await this.metadataService.getEndSessionEndpoint();if(!c)throw n.throw(new Error("No end session endpoint")),null;n.debug("Received end session endpoint",c),!r&&s&&!e&&(r=this.settings.client_id);const a=new _r({stateUrlParamValue:this._stateUrlParamValue,url:c,id_token_hint:e,client_id:r,post_logout_redirect_uri:s,state_data:t,extraQueryParams:o,request_type:i});await this.clearStaleState();const d=a.state;return d&&(n.debug("Signout request has state to persist"),await this.settings.stateStore.set(d.id,d.toStorageString())),a}async readSignoutResponseState(t,e=!1){const r=this._logger.create("readSignoutResponseState"),i=new mr(Fe.readParams(t,this.settings.response_mode));if(!i.state){if(r.debug("No state in response"),i.error)throw r.warn("Response was error:",i.error),new ue(i);return{state:void 0,response:i}}const s=await this.settings.stateStore[e?"remove":"get"](i.state);if(!s)throw r.throw(new Error("No matching state found in storage")),null;return{state:await Ne.fromStorageString(s),response:i}}async processSignoutResponse(t){const e=this._logger.create("processSignoutResponse"),{state:r,response:i}=await this.readSignoutResponseState(t,!0);return r?(e.debug("Received state from storage; validating response"),this._validator.validateSignoutResponse(i,r)):e.debug("No state from storage; skipping response validation"),i}clearStaleState(){return this._logger.create("clearStaleState"),Ne.clearStaleState(this.settings.stateStore,this.settings.staleStateAgeInSeconds)}async revokeToken(t,e){return this._logger.create("revokeToken"),await this._tokenClient.revoke({token:t,token_type_hint:e})}},kr=class{constructor(t){this._userManager=t,this._logger=new U("SessionMonitor"),this._start=async e=>{const r=e.session_state;if(!r)return;const i=this._logger.create("_start");if(e.profile?(this._sub=e.profile.sub,i.debug("session_state",r,", sub",this._sub)):(this._sub=void 0,i.debug("session_state",r,", anonymous user")),this._checkSessionIFrame){this._checkSessionIFrame.start(r);return}try{const s=await this._userManager.metadataService.getCheckSessionIframe();if(s){i.debug("initializing check session iframe");const o=this._userManager.settings.client_id,n=this._userManager.settings.checkSessionIntervalInSeconds,c=this._userManager.settings.stopCheckSessionOnError,a=new or(this._callback,o,s,n,c);await a.load(),this._checkSessionIFrame=a,a.start(r)}else i.warn("no check session iframe found in the metadata")}catch(s){i.error("Error from getCheckSessionIframe:",s instanceof Error?s.message:s)}},this._stop=()=>{const e=this._logger.create("_stop");if(this._sub=void 0,this._checkSessionIFrame&&this._checkSessionIFrame.stop(),this._userManager.settings.monitorAnonymousSession){const r=setInterval(async()=>{clearInterval(r);try{const i=await this._userManager.querySessionStatus();if(i){const s={session_state:i.session_state,profile:i.sub?{sub:i.sub}:null};this._start(s)}}catch(i){e.error("error from querySessionStatus",i instanceof Error?i.message:i)}},1e3)}},this._callback=async()=>{const e=this._logger.create("_callback");try{const r=await this._userManager.querySessionStatus();let i=!0;r&&this._checkSessionIFrame?r.sub===this._sub?(i=!1,this._checkSessionIFrame.start(r.session_state),e.debug("same sub still logged in at OP, session state has changed, restarting check session iframe; session_state",r.session_state),await this._userManager.events._raiseUserSessionChanged()):e.debug("different subject signed into OP",r.sub):e.debug("subject no longer signed into OP"),i?this._sub?await this._userManager.events._raiseUserSignedOut():await this._userManager.events._raiseUserSignedIn():e.debug("no change in session detected, no event to raise")}catch(r){this._sub&&(e.debug("Error calling queryCurrentSigninSession; raising signed out event",r),await this._userManager.events._raiseUserSignedOut())}},t||this._logger.throw(new Error("No user manager passed")),this._userManager.events.addUserLoaded(this._start),this._userManager.events.addUserUnloaded(this._stop),this._init().catch(e=>{this._logger.error(e)})}async _init(){this._logger.create("_init");const t=await this._userManager.getUser();if(t)this._start(t);else if(this._userManager.settings.monitorAnonymousSession){const e=await this._userManager.querySessionStatus();if(e){const r={session_state:e.session_state,profile:e.sub?{sub:e.sub}:null};this._start(r)}}}},qe=class Et{constructor(e){var r;this.id_token=e.id_token,this.session_state=(r=e.session_state)!=null?r:null,this.access_token=e.access_token,this.refresh_token=e.refresh_token,this.token_type=e.token_type,this.scope=e.scope,this.profile=e.profile,this.expires_at=e.expires_at,this.state=e.userState,this.url_state=e.url_state,this.__oidc_spa_tokenResponse=e.__oidc_spa_tokenResponse,this.__oidc_spa_localTimeWhenTokenIssued=e.__oidc_spa_localTimeWhenTokenIssued}get expires_in(){if(this.expires_at!==void 0)return this.expires_at-Y.getEpochTime()}set expires_in(e){e!==void 0&&(this.expires_at=Math.floor(e)+Y.getEpochTime())}get expired(){const e=this.expires_in;if(e!==void 0)return e<=0}get scopes(){var e,r;return(r=(e=this.scope)==null?void 0:e.split(" "))!=null?r:[]}toStorageString(){return new U("User").create("toStorageString"),JSON.stringify({id_token:this.id_token,session_state:this.session_state,access_token:this.access_token,refresh_token:this.refresh_token,token_type:this.token_type,scope:this.scope,profile:this.profile,expires_at:this.expires_at,__oidc_spa_tokenResponse:this.__oidc_spa_tokenResponse,__oidc_spa_localTimeWhenTokenIssued:this.__oidc_spa_localTimeWhenTokenIssued})}static fromStorageString(e){return U.createStatic("User","fromStorageString"),new Et(JSON.parse(e))}},ct="oidc-client",Ut=class{constructor(){this._abort=new ie("Window navigation aborted"),this._disposeHandlers=new Set,this._window=null}async navigate(t){const e=this._logger.create("navigate");if(!this._window)throw new Error("Attempted to navigate on a disposed window");e.debug("setting URL in window"),this._window.location.replace(t.url);const{url:r,keepOpen:i}=await new Promise((s,o)=>{const n=c=>{var a;const d=c.data,l=(a=t.scriptOrigin)!=null?a:window.location.origin;if(!(c.origin!==l||d?.source!==ct)){try{const u=Fe.readParams(d.url,t.response_mode).get("state");if(u||e.warn("no state found in response url"),c.source!==this._window&&u!==t.state)return}catch{this._dispose(),o(new Error("Invalid response from window"))}s(d)}};window.addEventListener("message",n,!1),this._disposeHandlers.add(()=>window.removeEventListener("message",n,!1)),this._disposeHandlers.add(this._abort.addHandler(c=>{this._dispose(),o(c)}))});return e.debug("got response from window"),this._dispose(),i||this.close(),{url:r}}_dispose(){this._logger.create("_dispose");for(const t of this._disposeHandlers)t();this._disposeHandlers.clear()}static _notifyParent(t,e,r=!1,i=window.location.origin){t.postMessage({source:ct,url:e,keepOpen:r},i)}},Rt={location:!1,toolbar:!1,height:640,closePopupWindowAfterInSeconds:-1},Pt="_blank",br=60,Tr=2,xt=10,Ir=class extends Ke{constructor(t){const{popup_redirect_uri:e=t.redirect_uri,popup_post_logout_redirect_uri:r=t.post_logout_redirect_uri,popupWindowFeatures:i=Rt,popupWindowTarget:s=Pt,redirectMethod:o="assign",redirectTarget:n="self",iframeNotifyParentOrigin:c=t.iframeNotifyParentOrigin,iframeScriptOrigin:a=t.iframeScriptOrigin,requestTimeoutInSeconds:d,silent_redirect_uri:l=t.redirect_uri,silentRequestTimeoutInSeconds:u,automaticSilentRenew:g=!0,validateSubOnSilentRenew:S=!0,includeIdTokenInSilentRenew:f=!1,monitorSession:h=!1,monitorAnonymousSession:p=!1,checkSessionIntervalInSeconds:x=Tr,query_status_response_type:k="code",stopCheckSessionOnError:_=!0,revokeTokenTypes:q=["access_token","refresh_token"],revokeTokensOnSignout:B=!1,includeIdTokenInSilentSignout:N=!1,accessTokenExpiringNotificationTimeInSeconds:E=br,userStore:b}=t;if(super(t),this.popup_redirect_uri=e,this.popup_post_logout_redirect_uri=r,this.popupWindowFeatures=i,this.popupWindowTarget=s,this.redirectMethod=o,this.redirectTarget=n,this.iframeNotifyParentOrigin=c,this.iframeScriptOrigin=a,this.silent_redirect_uri=l,this.silentRequestTimeoutInSeconds=u||d||xt,this.automaticSilentRenew=g,this.validateSubOnSilentRenew=S,this.includeIdTokenInSilentRenew=f,this.monitorSession=h,this.monitorAnonymousSession=p,this.checkSessionIntervalInSeconds=x,this.stopCheckSessionOnError=_,this.query_status_response_type=k,this.revokeTokenTypes=q,this.revokeTokensOnSignout=B,this.includeIdTokenInSilentSignout=N,this.accessTokenExpiringNotificationTimeInSeconds=E,b)this.userStore=b;else{const A=typeof window<"u"?window.sessionStorage:new et;this.userStore=new Ae({store:A})}}},dt=class Ot extends Ut{constructor({silentRequestTimeoutInSeconds:e=xt}){super(),this._logger=new U("IFrameWindow"),this._timeoutInSeconds=e,this._frame=Ot.createHiddenIframe(),this._window=this._frame.contentWindow}static createHiddenIframe(){const e=window.document.createElement("iframe");return e.style.visibility="hidden",e.style.position="fixed",e.style.left="-1000px",e.style.top="0",e.width="0",e.height="0",window.document.body.appendChild(e),e}async navigate(e){this._logger.debug("navigate: Using timeout of:",this._timeoutInSeconds);const r=setTimeout(()=>void this._abort.raise(new Ze("IFrame timed out without a response")),this._timeoutInSeconds*1e3);return this._disposeHandlers.add(()=>clearTimeout(r)),await super.navigate(e)}close(){var e;this._frame&&(this._frame.parentNode&&(this._frame.addEventListener("load",r=>{var i;const s=r.target;(i=s.parentNode)==null||i.removeChild(s),this._abort.raise(new Error("IFrame removed from DOM"))},!0),(e=this._frame.contentWindow)==null||e.location.replace("about:blank")),this._frame=null),this._window=null}static notifyParent(e,r){return super._notifyParent(window.parent,e,!1,r)}},Er=class{constructor(t){this._settings=t,this._logger=new U("IFrameNavigator")}async prepare({silentRequestTimeoutInSeconds:t=this._settings.silentRequestTimeoutInSeconds}){return new dt({silentRequestTimeoutInSeconds:t})}async callback(t){this._logger.create("callback"),dt.notifyParent(t,this._settings.iframeNotifyParentOrigin)}},Ur=500,Rr=1e3,lt=class extends Ut{constructor({popupWindowTarget:t=Pt,popupWindowFeatures:e={},popupSignal:r}){super(),this._logger=new U("PopupWindow");const i=at.center({...Rt,...e});this._window=window.open(void 0,t,at.serialize(i)),r&&r.addEventListener("abort",()=>{var s;this._abort.raise(new Error((s=r.reason)!=null?s:"Popup aborted"))}),e.closePopupWindowAfterInSeconds&&e.closePopupWindowAfterInSeconds>0&&setTimeout(()=>{if(!this._window||typeof this._window.closed!="boolean"||this._window.closed){this._abort.raise(new Error("Popup blocked by user"));return}this.close()},e.closePopupWindowAfterInSeconds*Rr)}async navigate(t){var e;(e=this._window)==null||e.focus();const r=setInterval(()=>{(!this._window||this._window.closed)&&this._abort.raise(new Error("Popup closed by user"))},Ur);return this._disposeHandlers.add(()=>clearInterval(r)),await super.navigate(t)}close(){this._window&&(this._window.closed||(this._window.close(),this._abort.raise(new Error("Popup closed")))),this._window=null}static notifyOpener(t,e){if(!window.opener)throw new Error("No window.opener. Can't complete notification.");return super._notifyParent(window.opener,t,e)}},Pr=class{constructor(t){this._settings=t,this._logger=new U("PopupNavigator")}async prepare({popupWindowFeatures:t=this._settings.popupWindowFeatures,popupWindowTarget:e=this._settings.popupWindowTarget,popupSignal:r}){return new lt({popupWindowFeatures:t,popupWindowTarget:e,popupSignal:r})}async callback(t,{keepOpen:e=!1}){this._logger.create("callback"),lt.notifyOpener(t,e)}},xr=class{constructor(t){this._settings=t,this._logger=new U("RedirectNavigator")}async prepare({redirectMethod:t=this._settings.redirectMethod,redirectTarget:e=this._settings.redirectTarget}){var r;this._logger.create("prepare");let i=window.self;e==="top"&&(i=(r=window.top)!=null?r:window.self);const s=i.location[t].bind(i.location);let o;return{navigate:async n=>{this._logger.create("navigate");const c=new Promise((a,d)=>{o=d});return s(n.url),await c},close:()=>{this._logger.create("close"),o?.(new Error("Redirect aborted")),i.stop()}}}async callback(){}},Or=class extends nr{constructor(t){super({expiringNotificationTimeInSeconds:t.accessTokenExpiringNotificationTimeInSeconds}),this._logger=new U("UserManagerEvents"),this._userLoaded=new ie("User loaded"),this._userUnloaded=new ie("User unloaded"),this._silentRenewError=new ie("Silent renew error"),this._userSignedIn=new ie("User signed in"),this._userSignedOut=new ie("User signed out"),this._userSessionChanged=new ie("User session changed")}async load(t,e=!0){super.load(t),e&&await this._userLoaded.raise(t)}async unload(){super.unload(),await this._userUnloaded.raise()}addUserLoaded(t){return this._userLoaded.addHandler(t)}removeUserLoaded(t){return this._userLoaded.removeHandler(t)}addUserUnloaded(t){return this._userUnloaded.addHandler(t)}removeUserUnloaded(t){return this._userUnloaded.removeHandler(t)}addSilentRenewError(t){return this._silentRenewError.addHandler(t)}removeSilentRenewError(t){return this._silentRenewError.removeHandler(t)}async _raiseSilentRenewError(t){await this._silentRenewError.raise(t)}addUserSignedIn(t){return this._userSignedIn.addHandler(t)}removeUserSignedIn(t){this._userSignedIn.removeHandler(t)}async _raiseUserSignedIn(){await this._userSignedIn.raise()}addUserSignedOut(t){return this._userSignedOut.addHandler(t)}removeUserSignedOut(t){this._userSignedOut.removeHandler(t)}async _raiseUserSignedOut(){await this._userSignedOut.raise()}addUserSessionChanged(t){return this._userSessionChanged.addHandler(t)}removeUserSessionChanged(t){this._userSessionChanged.removeHandler(t)}async _raiseUserSessionChanged(){await this._userSessionChanged.raise()}},Cr=class{constructor(t){this._userManager=t,this._logger=new U("SilentRenewService"),this._isStarted=!1,this._retryTimer=new Y("Retry Silent Renew"),this._tokenExpiring=async()=>{const e=this._logger.create("_tokenExpiring");try{await this._userManager.signinSilent({transformUrl:r=>r}),e.debug("silent token renewal successful")}catch(r){if(r instanceof Ze){e.warn("ErrorTimeout from signinSilent:",r,"retry in 5s"),this._retryTimer.init(5);return}e.error("Error from signinSilent:",r),await this._userManager.events._raiseSilentRenewError(r)}}}async start(){const t=this._logger.create("start");if(!this._isStarted){this._isStarted=!0,this._userManager.events.addAccessTokenExpiring(this._tokenExpiring),this._retryTimer.addHandler(this._tokenExpiring);try{await this._userManager.getUser()}catch(e){t.error("getUser error",e)}}}stop(){this._isStarted&&(this._retryTimer.cancel(),this._retryTimer.removeHandler(this._tokenExpiring),this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring),this._isStarted=!1)}},Ar=class{constructor(t){this.refresh_token=t.refresh_token,this.id_token=t.id_token,this.session_state=t.session_state,this.scope=t.scope,this.profile=t.profile,this.data=t.state}},Nr=class{constructor(t,e,r,i){this._logger=new U("UserManager"),this._stateUrlParamValue=t.stateUrlParamValue,this.settings=new Ir(t),this._client=new Sr(t),this._redirectNavigator=e??new xr(this.settings),this._popupNavigator=r??new Pr(this.settings),this._iframeNavigator=i??new Er(this.settings),this._events=new Or(this.settings),this._silentRenewService=new Cr(this),this.settings.automaticSilentRenew&&this.startSilentRenew(),this._sessionMonitor=null,this.settings.monitorSession&&(this._sessionMonitor=new kr(this))}get events(){return this._events}get metadataService(){return this._client.metadataService}async getUser(){const t=this._logger.create("getUser"),e=await this._loadUser();return e?(t.info("user loaded"),await this._events.load(e,!1),e):(t.info("user not found in storage"),null)}async removeUser(){const t=this._logger.create("removeUser");await this.storeUser(null),t.info("user removed from storage"),await this._events.unload()}async signinRedirect(t){var e;this._logger.create("signinRedirect");const{redirectMethod:r,...i}=t;let s;(e=this.settings.dpop)!=null&&e.bind_authorization_code&&(s=await this.generateDPoPJkt(this.settings.dpop));const o=await this._redirectNavigator.prepare({redirectMethod:r});await this._signinStart({stateUrlParamValue:this._stateUrlParamValue,request_type:"si:r",dpopJkt:s,...i},o)}async signinRedirectCallback(t=window.location.href){const e=this._logger.create("signinRedirectCallback"),r=await this._signinEnd(t);return r.profile&&r.profile.sub?e.info("success, signed in subject",r.profile.sub):e.info("no subject"),r}async signinResourceOwnerCredentials({username:t,password:e,skipUserInfo:r=!1}){const i=this._logger.create("signinResourceOwnerCredential"),s=await this._client.processResourceOwnerPasswordCredentials({username:t,password:e,skipUserInfo:r,extraTokenParams:this.settings.extraTokenParams});i.debug("got signin response");const o=await this._buildUser(s);return o.profile&&o.profile.sub?i.info("success, signed in subject",o.profile.sub):i.info("no subject"),o}async signinPopup(t={}){var e;const r=this._logger.create("signinPopup");let i;(e=this.settings.dpop)!=null&&e.bind_authorization_code&&(i=await this.generateDPoPJkt(this.settings.dpop));const{popupWindowFeatures:s,popupWindowTarget:o,popupSignal:n,...c}=t,a=this.settings.popup_redirect_uri;a||r.throw(new Error("No popup_redirect_uri configured"));const d=await this._popupNavigator.prepare({popupWindowFeatures:s,popupWindowTarget:o,popupSignal:n}),l=await this._signin({stateUrlParamValue:this._stateUrlParamValue,request_type:"si:p",redirect_uri:a,display:"popup",dpopJkt:i,transformUrl:u=>u,...c},d);return l&&(l.profile&&l.profile.sub?r.info("success, signed in subject",l.profile.sub):r.info("no subject")),l}async signinPopupCallback(t=window.location.href,e=!1){const r=this._logger.create("signinPopupCallback");await this._popupNavigator.callback(t,{keepOpen:e}),r.info("success")}async signinSilent(t){var e,r;const i=this._logger.create("signinSilent"),{silentRequestTimeoutInSeconds:s,...o}=t;let n=await this._loadUser();if(n?.refresh_token){i.debug("using refresh token");const u=new Ar(n);return await this._useRefreshToken({state:u,redirect_uri:o.redirect_uri,resource:o.resource,extraTokenParams:o.extraTokenParams,timeoutInSeconds:s})}let c;(e=this.settings.dpop)!=null&&e.bind_authorization_code&&(c=await this.generateDPoPJkt(this.settings.dpop));const a=this.settings.silent_redirect_uri;a||i.throw(new Error("No silent_redirect_uri configured"));let d;n&&this.settings.validateSubOnSilentRenew&&(i.debug("subject prior to silent renew:",n.profile.sub),d=n.profile.sub);const l=await this._iframeNavigator.prepare({silentRequestTimeoutInSeconds:s});return n=await this._signin({stateUrlParamValue:this._stateUrlParamValue,request_type:"si:s",redirect_uri:a,prompt:"none",id_token_hint:this.settings.includeIdTokenInSilentRenew?n?.id_token:void 0,dpopJkt:c,...o},l,d),n&&((r=n.profile)!=null&&r.sub?i.info("success, signed in subject",n.profile.sub):i.info("no subject")),n}async _useRefreshToken(t){const e=await this._client.useRefreshToken({timeoutInSeconds:this.settings.silentRequestTimeoutInSeconds,...t});if(e.__oidc_spa_tokenResponse===void 0||e.__oidc_spa_localTimeWhenTokenIssued===void 0)throw new Error("Wrong Assertion Encountered: Error in oidc-spa mod of oidc-client-ts");const r=new qe({...t.state,...e,__oidc_spa_tokenResponse:e.__oidc_spa_tokenResponse,__oidc_spa_localTimeWhenTokenIssued:e.__oidc_spa_localTimeWhenTokenIssued});return await this.storeUser(r),await this._events.load(r),r}async signinSilentCallback(t=window.location.href){const e=this._logger.create("signinSilentCallback");await this._iframeNavigator.callback(t),e.info("success")}async signinCallback(t=window.location.href){const{state:e}=await this._client.readSigninResponseState(t);switch(e.request_type){case"si:r":return await this.signinRedirectCallback(t);case"si:p":await this.signinPopupCallback(t);break;case"si:s":await this.signinSilentCallback(t);break;default:throw new Error("invalid response_type in state")}}async signoutCallback(t=window.location.href,e=!1){const{state:r}=await this._client.readSignoutResponseState(t);if(r)switch(r.request_type){case"so:r":return await this.signoutRedirectCallback(t);case"so:p":await this.signoutPopupCallback(t,e);break;case"so:s":await this.signoutSilentCallback(t);break;default:throw new Error("invalid response_type in state")}}async querySessionStatus(t={}){const e=this._logger.create("querySessionStatus"),{silentRequestTimeoutInSeconds:r,...i}=t,s=this.settings.silent_redirect_uri;s||e.throw(new Error("No silent_redirect_uri configured"));const o=await this._loadUser(),n=await this._iframeNavigator.prepare({silentRequestTimeoutInSeconds:r}),c=await this._signinStart({stateUrlParamValue:this._stateUrlParamValue,request_type:"si:s",redirect_uri:s,prompt:"none",id_token_hint:this.settings.includeIdTokenInSilentRenew?o?.id_token:void 0,response_type:this.settings.query_status_response_type,scope:"openid",skipUserInfo:!0,transformUrl:a=>a,...i},n);try{const a={},d=await this._client.processSigninResponse(c.url,a);return e.debug("got signin response"),d.session_state&&d.profile.sub?(e.info("success for subject",d.profile.sub),{session_state:d.session_state,sub:d.profile.sub}):(e.info("success, user not authenticated"),null)}catch(a){if(this.settings.monitorAnonymousSession&&a instanceof ue)switch(a.error){case"login_required":case"consent_required":case"interaction_required":case"account_selection_required":return e.info("success for anonymous user"),{session_state:a.session_state}}throw a}}async _signin(t,e,r){const i=await this._signinStart(t,e);return await this._signinEnd(i.url,r)}async _signinStart(t,e){const r=this._logger.create("_signinStart");try{const i=await this._client.createSigninRequest(t);return r.debug("got signin request"),await e.navigate({url:i.url,state:i.state.id,response_mode:i.state.response_mode,scriptOrigin:this.settings.iframeScriptOrigin})}catch(i){throw r.debug("error after preparing navigator, closing navigator window"),e.close(),i}}async _signinEnd(t,e){const r=this._logger.create("_signinEnd"),i={},s=await this._client.processSigninResponse(t,i);return r.debug("got signin response"),await this._buildUser(s,e)}async _buildUser(t,e){const r=this._logger.create("_buildUser");if(t.__oidc_spa_tokenResponse===void 0||t.__oidc_spa_localTimeWhenTokenIssued===void 0)throw new Error("Wrong Assertion Encountered: Error in oidc-spa mod of oidc-client-ts");const i=new qe({...t,__oidc_spa_tokenResponse:t.__oidc_spa_tokenResponse,__oidc_spa_localTimeWhenTokenIssued:t.__oidc_spa_localTimeWhenTokenIssued});if(e){if(e!==i.profile.sub)throw r.debug("current user does not match user returned from signin. sub from signin:",i.profile.sub),new ue({...t,error:"login_required"});r.debug("current user matches user returned from signin")}return await this.storeUser(i),r.debug("user stored"),await this._events.load(i),i}async signoutRedirect(t={}){const e=this._logger.create("signoutRedirect"),{redirectMethod:r,...i}=t,s=await this._redirectNavigator.prepare({redirectMethod:r});await this._signoutStart({stateUrlParamValue:this._stateUrlParamValue,request_type:"so:r",post_logout_redirect_uri:this.settings.post_logout_redirect_uri,...i},s),e.info("success")}async signoutRedirectCallback(t=window.location.href){const e=this._logger.create("signoutRedirectCallback"),r=await this._signoutEnd(t);return e.info("success"),r}async signoutPopup(t={}){const e=this._logger.create("signoutPopup"),{popupWindowFeatures:r,popupWindowTarget:i,popupSignal:s,...o}=t,n=this.settings.popup_post_logout_redirect_uri,c=await this._popupNavigator.prepare({popupWindowFeatures:r,popupWindowTarget:i,popupSignal:s});await this._signout({stateUrlParamValue:this._stateUrlParamValue,request_type:"so:p",post_logout_redirect_uri:n,state:n==null?void 0:{},...o},c),e.info("success")}async signoutPopupCallback(t=window.location.href,e=!1){const r=this._logger.create("signoutPopupCallback");await this._popupNavigator.callback(t,{keepOpen:e}),r.info("success")}async _signout(t,e){const r=await this._signoutStart(t,e);return await this._signoutEnd(r.url)}async _signoutStart(t,e){var r;const i=this._logger.create("_signoutStart");try{const s=await this._loadUser();i.debug("loaded current user from storage"),this.settings.revokeTokensOnSignout&&await this._revokeInternal(s);const o=t.id_token_hint||s&&s.id_token;o&&(i.debug("setting id_token_hint in signout request"),t.id_token_hint=o),await this.removeUser(),i.debug("user removed, creating signout request");const n=await this._client.createSignoutRequest(t);return i.debug("got signout request"),await e.navigate({url:n.url,state:(r=n.state)==null?void 0:r.id,scriptOrigin:this.settings.iframeScriptOrigin})}catch(s){throw i.debug("error after preparing navigator, closing navigator window"),e.close(),s}}async _signoutEnd(t){const e=this._logger.create("_signoutEnd"),r=await this._client.processSignoutResponse(t);return e.debug("got signout response"),r}async signoutSilent(t={}){var e;const r=this._logger.create("signoutSilent"),{silentRequestTimeoutInSeconds:i,...s}=t,o=this.settings.includeIdTokenInSilentSignout?(e=await this._loadUser())==null?void 0:e.id_token:void 0,n=this.settings.popup_post_logout_redirect_uri,c=await this._iframeNavigator.prepare({silentRequestTimeoutInSeconds:i});await this._signout({stateUrlParamValue:this._stateUrlParamValue,request_type:"so:s",post_logout_redirect_uri:n,id_token_hint:o,...s},c),r.info("success")}async signoutSilentCallback(t=window.location.href){const e=this._logger.create("signoutSilentCallback");await this._iframeNavigator.callback(t),e.info("success")}async revokeTokens(t){const e=await this._loadUser();await this._revokeInternal(e,t)}async _revokeInternal(t,e=this.settings.revokeTokenTypes){const r=this._logger.create("_revokeInternal");if(!t)return;const i=e.filter(s=>typeof t[s]=="string");if(!i.length){r.debug("no need to revoke due to no token(s)");return}for(const s of i)await this._client.revokeToken(t[s],s),r.info(`${s} revoked successfully`),s!=="access_token"&&(t[s]=null);await this.storeUser(t),r.debug("user stored"),await this._events.load(t)}startSilentRenew(){this._logger.create("startSilentRenew"),this._silentRenewService.start()}stopSilentRenew(){this._silentRenewService.stop()}get _userStoreKey(){return`user:${this.settings.authority}:${this.settings.client_id}`}async _loadUser(){const t=this._logger.create("_loadUser"),e=await this.settings.userStore.get(this._userStoreKey);return e?(t.debug("user storageString loaded"),qe.fromStorageString(e)):(t.debug("no user storageString"),null)}async storeUser(t){const e=this._logger.create("storeUser");if(t){e.debug("storing user");const r=t.toStorageString();await this.settings.userStore.set(this._userStoreKey,r)}else this._logger.debug("removing user"),await this.settings.userStore.remove(this._userStoreKey),this.settings.dpop&&await this.settings.dpop.store.remove(this.settings.client_id)}async clearStaleState(){await this._client.clearStaleState()}async dpopProof(t,e,r,i){var s,o;const n=await((o=(s=this.settings.dpop)==null?void 0:s.store)==null?void 0:o.get(this.settings.client_id));if(n)return await F.generateDPoPProof({url:t,accessToken:e?.access_token,httpMethod:r,keyPair:n.keys,nonce:i})}async generateDPoPJkt(t){let e=await t.store.get(this.settings.client_id);if(!e){const r=await F.generateDPoPKeys();e=new It(r),await t.store.set(this.settings.client_id,e)}return await F.generateDPoPJkt(e.keys)}};function Ct(){const t=window.location.origin;return!!(/^https?:\/\/localhost/.test(t)||/^https?:\/\/\[::\]/.test(t)||/^https?:\/\/127.0.0.1/.test(t))}const Lr="/.well-known/openid-configuration";function At(t){const{issuerUri:e}=t;return`oidc-spa:openid-configuration:${e}`}function Mr(t){const{issuerUri:e}=t,r=sessionStorage.getItem(At({issuerUri:e}));if(r!==null)return JSON.parse(r)}function Dr(t){const{issuerUri:e,oidcMetadata:r}=t;sessionStorage.setItem(At({issuerUri:e}),JSON.stringify(r))}async function $r(t){const{issuerUri:e}=t;e:{const i=Mr({issuerUri:e});if(i===void 0)break e;return i}let r;try{const i=await fetch(`${e}${Lr}`,{headers:{Accept:"application/jwk-set+json, application/json"}});if(!i.ok)throw new Error;const s=await i.json();{const{authorization_endpoint:o}=s;if(typeof o!="string")throw new Error}r=s}catch{return}return Ct()||Dr({issuerUri:e,oidcMetadata:r}),r}var qr=Object.create,rt=Object.defineProperty,jr=Object.getOwnPropertyDescriptor,Nt=Object.getOwnPropertyNames,Br=Object.getPrototypeOf,Wr=Object.prototype.hasOwnProperty,Hr=(t,e)=>function(){return e||(0,t[Nt(t)[0]])((e={exports:{}}).exports,e),e.exports},Fr=(t,e)=>{for(var r in e)rt(t,r,{get:e[r],enumerable:!0})},Jr=(t,e,r,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Nt(e))!Wr.call(t,s)&&s!==r&&rt(t,s,{get:()=>e[s],enumerable:!(i=jr(e,s))||i.enumerable});return t},zr=(t,e,r)=>(r=t!=null?qr(Br(t)):{},Jr(!t||!t.__esModule?rt(r,"default",{value:t,enumerable:!0}):r,t)),Kr=Hr({"node_modules/fast-unique-numbers/build/es5/bundle.js"(t,e){(function(r,i){typeof t=="object"&&typeof e<"u"?i(t):typeof define=="function"&&define.amd?define(["exports"],i):(r=typeof globalThis<"u"?globalThis:r||self,i(r.fastUniqueNumbers={}))})(t,(function(r){var i=function(f){return function(h){var p=f(h);return h.add(p),p}},s=function(f){return function(h,p){return f.set(h,p),p}},o=Number.MAX_SAFE_INTEGER===void 0?9007199254740991:Number.MAX_SAFE_INTEGER,n=536870912,c=n*2,a=function(f,h){return function(p){var x=h.get(p),k=x===void 0?p.size:x<c?x+1:0;if(!p.has(k))return f(p,k);if(p.size<n){for(;p.has(k);)k=Math.floor(Math.random()*c);return f(p,k)}if(p.size>o)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;p.has(k);)k=Math.floor(Math.random()*o);return f(p,k)}},d=new WeakMap,l=s(d),u=a(l,d),g=i(u);r.addUniqueNumber=g,r.generateUniqueNumber=u}))}}),we={};Fr(we,{clearInterval:()=>Zr,clearTimeout:()=>ei,setInterval:()=>ti,setTimeout:()=>ri});var Ie=zr(Kr()),Vr=t=>t.method!==void 0&&t.method==="call",Qr=t=>t.error===null&&typeof t.id=="number",Gr=t=>{const e=new Map([[0,()=>{}]]),r=new Map([[0,()=>{}]]),i=new Map,s=new Worker(t);return s.addEventListener("message",({data:d})=>{if(Vr(d)){const{params:{timerId:l,timerType:u}}=d;if(u==="interval"){const g=e.get(l);if(typeof g=="number"){const S=i.get(g);if(S===void 0||S.timerId!==l||S.timerType!==u)throw new Error("The timer is in an undefined state.")}else if(typeof g<"u")g();else throw new Error("The timer is in an undefined state.")}else if(u==="timeout"){const g=r.get(l);if(typeof g=="number"){const S=i.get(g);if(S===void 0||S.timerId!==l||S.timerType!==u)throw new Error("The timer is in an undefined state.")}else if(typeof g<"u")g(),r.delete(l);else throw new Error("The timer is in an undefined state.")}}else if(Qr(d)){const{id:l}=d,u=i.get(l);if(u===void 0)throw new Error("The timer is in an undefined state.");const{timerId:g,timerType:S}=u;i.delete(l),S==="interval"?e.delete(g):r.delete(g)}else{const{error:{message:l}}=d;throw new Error(l)}}),{clearInterval:d=>{const l=(0,Ie.generateUniqueNumber)(i);i.set(l,{timerId:d,timerType:"interval"}),e.set(d,l),s.postMessage({id:l,method:"clear",params:{timerId:d,timerType:"interval"}})},clearTimeout:d=>{const l=(0,Ie.generateUniqueNumber)(i);i.set(l,{timerId:d,timerType:"timeout"}),r.set(d,l),s.postMessage({id:l,method:"clear",params:{timerId:d,timerType:"timeout"}})},setInterval:(d,l=0)=>{const u=(0,Ie.generateUniqueNumber)(e);return e.set(u,()=>{d(),typeof e.get(u)=="function"&&s.postMessage({id:null,method:"set",params:{delay:l,now:performance.now(),timerId:u,timerType:"interval"}})}),s.postMessage({id:null,method:"set",params:{delay:l,now:performance.now(),timerId:u,timerType:"interval"}}),u},setTimeout:(d,l=0)=>{const u=(0,Ie.generateUniqueNumber)(r);return r.set(u,d),s.postMessage({id:null,method:"set",params:{delay:l,now:performance.now(),timerId:u,timerType:"timeout"}}),u}}},Yr=(t,e)=>{let r=null;return()=>{if(r!==null)return r;const i=new Blob([e],{type:"application/javascript; charset=utf-8"}),s=URL.createObjectURL(i);return r=t(s),setTimeout(()=>URL.revokeObjectURL(s)),r}},Xr=`(()=>{"use strict";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:"call",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener("message",(i=>{let{data:s}=i;try{if("clear"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if("interval"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if("timeout"!==i)throw new Error('The given type "'.concat(i,'" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if("set"!==s.method)throw new Error('The given method "'.concat(s.method,'" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if("interval"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,"interval"))})(i,a,n);else{if("timeout"!==d)throw new Error('The given type "'.concat(d,'" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,"timeout"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`,De=Yr(Gr,Xr),Zr=t=>De().clearInterval(t),ei=t=>De().clearTimeout(t),ti=(...t)=>De().setInterval(...t),ri=(...t)=>De().setTimeout(...t);const Pe=new WeakMap;function de(t,e){const r=()=>{window.removeEventListener("pageshow",n),Pe.delete(s),t()};let i=we.setTimeout(r,e);const s={};Pe.set(s,()=>{Pe.delete(s),we.clearTimeout(i),window.removeEventListener("pageshow",n)});const o=Date.now(),n=()=>{we.clearTimeout(i);const c=Date.now()-o;0<=c&&c<e?i=we.setTimeout(r,e-c):r()};return window.addEventListener("pageshow",n),s}function Le(t){const e=Pe.get(t);e!==void 0&&e()}function ii(){const t=new X,e=()=>{t.resolve(),r()},r=()=>{window.document.removeEventListener("mousemove",e,!1),window.document.removeEventListener("keydown",e,!1),window.document.removeEventListener("touchstart",e,!1),window.document.removeEventListener("touchend",e,!1)};return window.document.addEventListener("mousemove",e,!1),window.document.addEventListener("keydown",e,!1),window.document.addEventListener("touchstart",e,!1),window.document.addEventListener("touchend",e,!1),{prUserInteraction:t.pr,cancelPrUserInteraction:r}}function si(t){const{throttleMs:e}=t,r=new Set;return(async function s(){const{cancelPrUserInteraction:o,prUserInteraction:n}=ii();r.add(o),await n,t.callback(),await new Promise(c=>{const a=setTimeout(c,e);r.add(()=>{clearTimeout(a)})}),r.clear(),s()})(),{unsubscribeFromUserInteraction:()=>{Array.from(r).forEach(s=>s())}}}const Ee={appInstanceId:Math.random().toString(36).slice(2),evtIsUserActiveBySessionId:new Map};function ni(t){const{configId:e,sessionId:r}=t;e:{if(r===void 0)break e;const l=Ee.evtIsUserActiveBySessionId.get(r);if(l===void 0)break e;return l}const{notifyOtherTabsOfUserInteraction:i,subscribeToUserInteractionOnOtherTabs:s}=(()=>{const l=`oidc-spa:user-interaction-tracker:${r??e}`;function u(){new BroadcastChannel(l).postMessage($({appInstanceId:Ee.appInstanceId}))}function g(S){const f=new BroadcastChannel(l);f.onmessage=({data:h})=>{y(Ye()),h.appInstanceId!==Ee.appInstanceId&&S()}}return{notifyOtherTabsOfUserInteraction:u,subscribeToUserInteractionOnOtherTabs:g}})(),o=mt();let n=!0;const c=()=>{const l=de(()=>{y(n,"011507"),n=!1,o.post(n)},5e3);return()=>{Le(l),a=void 0}};let a=c();const d=l=>{const{isInteractionOnCurrentTab:u}=l;a?.(),a=c(),u&&i(),n||(n=!0,o.post(n))};return si({throttleMs:1e3,callback:()=>d({isInteractionOnCurrentTab:!0})}),s(()=>d({isInteractionOnCurrentTab:!1})),r!==void 0&&Ee.evtIsUserActiveBySessionId.set(r,o),o}function oi(t){const{tickCallback:e}=t;function r(i){const{countDownFromSeconds:s}=i;let o;return(async()=>{let c=Math.floor(s);for(;c>=0;)e({secondsLeft:c}),await new Promise(a=>{o=de(a,1e3)}),c--})(),{stopCountdown:()=>{Le(o),e({secondsLeft:void 0})}}}return{startCountdown:r}}function H(t){const e=Math.floor(t/1e3);if(e<60)return`${Math.round(t/1e3)} seconds`;if(e<3600){const r=Math.floor(e/60),i=e%60;return`${r} minutes ${i} seconds`}else if(e<86400){const r=Math.floor(e/3600),i=Math.floor(e%3600/60),s=e%60;return`${r} hours ${i} minutes ${s} seconds`}else{const r=Math.floor(e/86400),i=Math.floor(e%86400/3600),s=Math.floor(e%3600/60);return`${r} days ${i} hours ${s} minutes`}}const Lt={appInstanceId:Math.random().toString(36).slice(2)};function Mt(t){const{sessionIdOrConfigId:e}=t;return`oidc-spa:logout-propagation:${e}`}function ut(t){const{configId:e,sessionId:r}=t,i={configId:e,appInstanceId:Lt.appInstanceId};new BroadcastChannel(Mt({sessionIdOrConfigId:r??e})).postMessage(i)}function ai(t){const{sessionId:e,configId:r}=t,i=new X,s=new BroadcastChannel(Mt({sessionIdOrConfigId:e??r}));return s.onmessage=({data:n})=>{y(Ye()),n.appInstanceId!==Lt.appInstanceId&&(s.close(),i.resolve())},{prOtherTabLogout:i.pr}}const Dt={appInstanceId:Math.random().toString(36).slice(2)};function $t(t){const{configId:e}=t;return`oidc-spa:login-propagation:${e}`}function ci(t){const{configId:e}=t,r={configId:e,appInstanceId:Dt.appInstanceId};new BroadcastChannel($t({configId:e})).postMessage(r)}function di(t){const{configId:e}=t,r=new X,i=new BroadcastChannel($t({configId:e}));return i.onmessage=({data:o})=>{y(Ye()),o.appInstanceId!==Dt.appInstanceId&&(i.close(),r.resolve())},{prOtherTabLogin:r.pr}}function li(t){return`${t.issuerUri}:${t.clientId}`}class ve extends Error{}ve.prototype.name="InvalidTokenError";function ui(t){return decodeURIComponent(atob(t).replace(/(.)/g,(e,r)=>{let i=r.charCodeAt(0).toString(16).toUpperCase();return i.length<2&&(i="0"+i),"%"+i}))}function hi(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("base64 string is not of the correct length")}try{return ui(e)}catch{return atob(e)}}function gi(t,e){if(typeof t!="string")throw new ve("Invalid token specified: must be a string");e||(e={});const r=e.header===!0?0:1,i=t.split(".")[r];if(typeof i!="string")throw new ve(`Invalid token specified: missing part #${r+1}`);let s;try{s=hi(i)}catch(o){throw new ve(`Invalid token specified: invalid base64 for part #${r+1} (${o.message})`)}try{return JSON.parse(s)}catch(o){throw new ve(`Invalid token specified: invalid json for part #${r+1} (${o.message})`)}}const qt=gi;function je(t){let e;try{e=qt(t).exp,y(typeof e=="number")}catch{return}return e===0?se:e*1e3}function ht(t){const{oidcClientTsUser:e,decodedIdTokenSchema:r,__unsafe_useIdTokenAsAccessToken:i,decodedIdToken_previous:s,log:o}=t,n=s===void 0,c=e.access_token,a=e.refresh_token,d=e.id_token;y(d!==void 0,"No id token provided by the oidc server");const l=qt(d);n&&o?.(["Decoded ID token",r===void 0?"":" before `decodedIdTokenSchema.parse()`\n",JSON.stringify(l,null,2)].join(""));const u=(()=>{let h;return r!==void 0?(h=r.parse(l),n&&o?.(["Decoded ID token after `decodedIdTokenSchema.parse()`\n",JSON.stringify(h,null,2)].join(""))):h=l,s!==void 0&&JSON.stringify(h)===JSON.stringify(s)?s:h})(),g=(()=>{const h=(()=>{let p;try{const x=l.iat;y(x===void 0||typeof x=="number"),p=x}catch{p=void 0}if(p!==void 0)return p})();return h===void 0?Date.now():h*1e3})(),S={...i?{accessToken:d,accessTokenExpirationTime:(()=>{const h=je(d);return y(h!==void 0,"Failed to get id token expiration time while trying to substitute the access token by the id token"),h})()}:{accessToken:c,accessTokenExpirationTime:(()=>{e:{const h=je(c);if(h===void 0)break e;return h}e:{const{expires_at:h}=e.__oidc_spa_tokenResponse;if(h===void 0)break e;return y(typeof h=="number","2033392"),h*1e3}e:{const{expires_in:h}=e.__oidc_spa_tokenResponse;if(h===void 0)break e;return y(typeof h=="number","203333425"),g+h*1e3}y(!1,"Failed to get access token expiration time")})()},idToken:d,decodedIdToken:u,decodedIdToken_original:l,issuedAtTime:g,getServerDateNow:(()=>{const h=e.__oidc_spa_localTimeWhenTokenIssued;return()=>Date.now()+(g-h)})()},f=a===void 0?$({...S,hasRefreshToken:!1}):$({...S,hasRefreshToken:!0,refreshToken:a,refreshTokenExpirationTime:(()=>{e:{const{refresh_expires_at:h}=e.__oidc_spa_tokenResponse;if(h===void 0)break e;return y(typeof h=="number","2033392"),h===0?se:h*1e3}e:{const{refresh_expires_in:h}=e.__oidc_spa_tokenResponse;if(h===void 0)break e;return y(typeof h=="number","2033425330"),h===0?se:g+h*1e3}e:{const h=je(a);if(h===void 0)break e;return h}})()});return n&&f.hasRefreshToken&&f.refreshTokenExpirationTime!==void 0&&f.refreshTokenExpirationTime<f.accessTokenExpirationTime&&console.warn(["The OIDC refresh token expirationTime is shorter than the one of the access token.","This is very unusual and probably a misconfiguration."].join(" ")),f}function jt(t){const e={};for(const r in t)t[r]!==void 0&&(e[r]=t[r]);return e}function fi(){if(!(window.navigator instanceof Object))return;const t=window.navigator;for(const e of["connection","mozConnection","webkitConnection"])try{const{downlink:r,rtt:i}=t[e];return y(typeof r=="number","768860"),y(typeof i=="number","945829"),{downlink:r,rtt:i}}catch{}}var pi={};let Be;function _i(){return Be!==void 0?Be:Be=!!(/https?:\/\/localhost/.test(window.location.href)||(typeof process=="object"&&process!==null&&pi instanceof Object,document.querySelector('script[type="module"][src="/@vite/client"]')!==null))}function ye(){if(navigator.onLine)return{isOnline:!0};const t=new X,e=()=>{window.removeEventListener("online",e),t.resolve()};return window.addEventListener("online",e),{isOnline:!1,prOnline:t.pr}}async function gt(t){const{oidcClientTsUserManager:e,stateUrlParamValue_instance:r,configId:i,transformUrlBeforeRedirect:s,getExtraQueryParams:o,getExtraTokenParams:n,autoLogin:c,log:a}=t;e:{const{isOnline:f,prOnline:h}=ye();if(f)break e;a?.("The browser seems offline, waiting to get back a connection before proceeding to login"),await h}const d=new X,l=(()=>{const f=_i(),h=fi(),p=f?9e3:c?25e3:7e3;if(h===void 0)return p;const{downlink:x,rtt:k}=h,_=k*2.5+p/(x+1);return Math.max(p,_)})();let u;{let f=!1;const h=[setTimeout(()=>{d.resolve({outcome:"timeout"})},l),setTimeout(()=>{console.warn(["oidc-spa: Session restoration is taking longer than expected.","This likely indicates a misconfiguration.",`Waiting ${Math.floor(l/1e3)} seconds before running diagnostics.`,"Once the timeout expires, helpful debugging information will be printed to the console."].join(" ")),f=!0},2e3)];u=({wasSuccess:p})=>{h.forEach(clearTimeout),p&&f&&console.log(["oidc-spa: Never mind, the auth server was just slow to respond.","You can safely ignore the previous warning."].join(" "))}}const{unsubscribe:g}=Ht().subscribe(f=>{if(f.state!==r)return;g();const h=wt({stateUrlParamValue:f.state});y(h!==void 0,"765645"),y(h.context==="iframe","250711"),y(h.configId===i,"4922732"),u({wasSuccess:!0}),d.resolve({outcome:"got auth response from iframe",authResponse:f})}),S=f=>{e:{if(o===void 0)break e;const h=o({isSilent:!0,url:f});for(const[p,x]of Object.entries(h))x!==void 0&&(f=Xe({url:f,name:p,value:x,encodeMethod:"www-form"}))}e:{if(s===void 0)break e;f=s({authorizationUrl:f,isSilent:!0})}return f};return e.signinSilent({state:$({context:"iframe",configId:i}),silentRequestTimeoutInSeconds:l/1e3,extraTokenParams:n===void 0?void 0:jt(n()),transformUrl:S}).then(f=>{y(f!==null,"oidcClientTsUser is not supposed to be null here"),u({wasSuccess:!0}),g(),d.resolve({outcome:"token refreshed using refresh token",oidcClientTsUser:f})},()=>{}),d.pr.then(f=>{f.outcome==="timeout"&&(Ft({stateUrlParamValue:r}),g())}),d.pr}function Ue(t){let e="https://dummy.com";for(const[r,i]of Object.entries(t))i!==void 0&&(e=Xe({url:e,name:r,value:i,encodeMethod:"www-form"}));return e=`${e}#${e.split("?")[1]}`,e}function Bt(t){const{configId:e}=t;return`oidc-spa:auth-state:${e}`}function ae(t){const{configId:e,state:r}=t,i=Bt({configId:e});if(r===void 0){localStorage.removeItem(i);return}localStorage.setItem(i,JSON.stringify($((()=>{switch(r.stateDescription){case"logged in":return $({__brand:"PersistedAuthState-v1",stateDescription:"logged in",untilTime:(()=>{const{idleSessionLifetimeInSeconds:s,refreshTokenExpirationTime:o,serverDateNow:n}=r,c=(()=>{if(o===void 0)return;const l=o-n;return Date.now()+l})(),a=(()=>{if(s!==void 0)return Date.now()+s*1e3})(),d=Math.min(c??se,a??se);if(d!==se)return d})()});case"explicitly logged out":return $({__brand:"PersistedAuthState-v1",stateDescription:"explicitly logged out"})}})())))}function _e(t){const{configId:e}=t,r=Bt({configId:e}),i=localStorage.getItem(r);if(i===null)return;let s;try{s=JSON.parse(i)}catch{localStorage.removeItem(r);return}if(!Jt(s,s instanceof Object&&"__brand"in s&&s.__brand===$("PersistedAuthState-v1"))){localStorage.removeItem(r);return}if(s.stateDescription==="logged in"&&s.untilTime!==void 0&&s.untilTime<=Date.now()){localStorage.removeItem(r);return}return s.stateDescription}function mi(t){const{url1:e,url2:r}=t,i=new URL(e).hostname,s=new URL(r).hostname,o=n=>{const c=n.split(".");return c.slice(c.length-2).join(".")};return o(i)===o(s)}const xe={evtHasLoginBeenCalled:vt(()=>!1)};function ft(){const t=new X,{unsubscribe:e}=xe.evtHasLoginBeenCalled.subscribe(r=>{r||(e(),t.resolve())});return t.pr}function wi(t){const{configId:e,oidcClientTsUserManager:r,transformUrlBeforeRedirect:i,getExtraQueryParams:s,getExtraTokenParams:o,homeUrl:n,evtInitializationOutcomeUserNotLoggedIn:c,log:a}=t;let d;async function l(g){const{redirectUrl:S,extraQueryParams_local:f,transformUrlBeforeRedirect_local:h,...p}=g;a?.(`Calling loginOrGoToAuthServer ${JSON.stringify(g,null,2)}`);e:{const{isOnline:E,prOnline:b}=ye();if(E)break e;a?.("The browser seem offline, waiting to get back a connection before proceeding to login"),await b}e:{if(p.action!=="login")break e;if(xe.evtHasLoginBeenCalled.current)return a?.("login() has already been called, ignoring the call"),new Promise(()=>{});if(xe.evtHasLoginBeenCalled.current=!0,document.visibilityState!=="visible"){p.interaction;const E=new X,b=()=>{document.visibilityState==="visible"&&(document.removeEventListener("visibilitychange",b),E.resolve())};document.addEventListener("visibilitychange",b),await E.pr}t:{if(p.doForceReloadOnBfCache){const b=A=>{A.persisted&&location.reload()};window.addEventListener("pageshow",b);break t}const E=b=>{b.persisted&&(window.removeEventListener("pageshow",E),a?.("We came back from the login pages and the state of the app has been restored"),p.doNavigateBackToLastPublicUrlIfTheTheUserNavigateBack?d!==void 0?(a?.(`Loading last public route: ${d}`),window.location.href=d):(a?.("We don't know the last public route, navigating back in history"),window.history.back()):(a?.("The current page doesn't require auth, avoiding reloading the page"),xe.evtHasLoginBeenCalled.current=!1))};window.addEventListener("pageshow",E)}}const x=Me({urlish:S,doAssertNoQueryParams:!1});{const E=new URL(x),b=`${E.origin}${E.pathname}`;if(!b.replace(/\/?$/,"/").startsWith(n))throw new Error([`oidc-spa: redirect target ${b} is outside of your application.`,`The homeUrl that you have provided defines the root where your app is hosted: ${n}.
`,`This usually means one of the following:
`,"1) The homeUrl is not set correctly. It must be the actual hosting root (for Vite, typically `import.meta.env.BASE_URL`).\n","2) You are trying to redirect outside of your application, which is not allowed by OIDC."].join(" "))}const k=x.slice(window.location.origin.length);a?.(`redirectUrl: ${k}`);const _={context:"redirect",rootRelativeRedirectUrl:k,extraQueryParams:{},configId:e,action:"login",rootRelativeRedirectUrl_consentRequiredCase:(()=>{switch(p.action){case"login":return(d??n).slice(window.location.origin.length);case"go to auth server":return k}})()},q=p.action==="login"&&p.interaction==="ensure no interaction",B=E=>([[s,i===void 0?void 0:b=>i({isSilent:q,authorizationUrl:b})],[f,h]].forEach(([b,A],L,D)=>{const z=L!==D.length-1?void 0:E;e:{if(b===void 0)break e;const ne=typeof b=="function"?b({isSilent:q,url:E}):b;for(const[Z,j]of Object.entries(ne))j!==void 0&&(E=Xe({url:E,name:Z,value:j,encodeMethod:"www-form"}))}e:{if(A===void 0)break e;E=A(E)}e:{if(z===void 0)break e;const ne=ot(E),Z=ot(z);for(const[j,ee]of Object.entries(ne))Z[j]!==ee&&(_.extraQueryParams[j]=ee)}}),E),N=(()=>{switch(p.action){case"login":return p.doNavigateBackToLastPublicUrlIfTheTheUserNavigateBack?"replace":"assign";case"go to auth server":return"assign"}})();return a?.(`redirectMethod: ${N}`),p.action==="login"&&p.preRedirectHook?.(),r.signinRedirect({state:_,redirectMethod:N,prompt:(()=>{switch(p.action){case"go to auth server":return;case"login":switch(p.interaction){case"ensure no interaction":return"none";case"ensure interaction":return"login";case"directly redirect if active session show login otherwise":return}}})(),transformUrl:B,extraTokenParams:o===void 0?void 0:jt(o())}).then(()=>new Promise(()=>{}),E=>{if(E.message.includes("Crypto.subtle is available only in secure contexts"))throw new Error([`oidc-spa: ${E.message}.`,"To fix this error see:","https://docs.oidc-spa.dev/v/v8/resources/fixing-crypto.subtle-is-available-only-in-secure-contexts-https"].join(" "));y(!1,"224238482")})}const{unsubscribe:u}=c.subscribe(()=>{u();const g=history.pushState.bind(history);history.pushState=function(...f){return d=window.location.href,g(...f)}});return{loginOrGoToAuthServer:l}}function vi(t){const{storageId:e}=t,r=`lazy-session-storage:${e}:`,i=c=>`${r}${c}`,s=[];for(let c=0;c<sessionStorage.length;c++){const a=sessionStorage.key(c);if(y(a!==null,"470498"),!a.startsWith(r))continue;const d=sessionStorage.getItem(a);y(d!==null,"846771"),sessionStorage.removeItem(a),s.push({key:a.slice(r.length),value:d})}let o=!1;const n={persistCurrentStateAndSubsequentChanges:()=>{o=!0;for(let c=0;c<n.length;c++){const a=n.key(c);y(a!==null,"803385");const d=n.getItem(a);y(d!==null,"777098"),n.setItem(a,d)}},get length(){return s.length},key:c=>{const a=s[c];return a===void 0?null:a.key},removeItem:c=>{const a=s.find(l=>l.key===c);if(a===void 0)return;sessionStorage.removeItem(i(a.key));const d=s.indexOf(a);s.splice(d,1)},clear:()=>{for(let c=0;c<n.length;c++){const a=n.key(c);y(a!==null,"290875"),n.removeItem(a)}},getItem:c=>{const a=s.find(d=>d.key===c);return a===void 0?null:a.value},setItem:(c,a)=>{o&&sessionStorage.setItem(i(c),a);e:{const d=s.find(l=>l.key===c);if(d===void 0)break e;d.value=a;return}s.push({key:c,value:a})}};return n}const Se={prDone_arr:$([]),prUnlock:$(Promise.resolve())};async function pt(){await Se.prUnlock;const t=new X,{prDone_arr:e}=Se;e.push(t.pr);function r(){const i=e.indexOf(t.pr);y(i!==-1,"104044"),e.splice(i,1),t.resolve()}return{completeLoginOrRefreshProcess:r}}async function ce(t){const{prUnlock:e}=t,r=Se.prUnlock;Se.prUnlock=(async()=>{await r,await e})(),await Promise.all(Se.prDone_arr)}function yi(t){const{configId:e,evtInitializationOutcomeUserNotLoggedIn:r}=t,i=`oidc-spa.subject-id:${e}`;{const{unsubscribe:o}=r.subscribe(()=>{o(),sessionStorage.removeItem(i)})}function s(o){const{subjectId:n}=o,c=sessionStorage.getItem(i);return c===null||n!==c?(sessionStorage.setItem(i,n),!0):!1}return{getIsNewBrowserSession:s}}const Wt="oidc-spa:more-than-one-instance-cant-use-iframe",le=vt(()=>sessionStorage.getItem(Wt)!==null);let _t=0;function Si(){_t++,_t!==1&&(le.current||(sessionStorage.setItem(Wt,"true"),le.current=!0))}function ki(t){const{BASE_URL_params:e}=t;return{homeUrlAndRedirectUri:Me({urlish:(()=>{if(e!==void 0)return e;const i=zt();if(i===void 0)throw new Error(["oidc-spa: If you do not use the oidc-spa Vite plugin","you must provide the BASE_URL to the earlyInit() examples:","oidcSpaEarlyInit({ BASE_URL: import.meta.env.BASE_URL })","oidcSpaEarlyInit({ BASE_URL: '/' })","","You can also pass this parameter to createOidc({ BASE_URL: '...' })","or bootstrapOidc({ BASE_URL: '...' })"].join(`
`));return i})(),doAssertNoQueryParams:!0,doOutputWithTrailingSlash:!0})}}const bi="8.3.1",Ge={prOidcByConfigId:new Map,hasLogoutBeenCalled:$(!1)};async function Ti(t){for(const u of["issuerUri","clientId"]){const g=t[u];if(!g)throw new Error(`The parameter "${u}" is required, you provided: ${g}. (Forgot a .env variable?)`)}const{issuerUri:e,clientId:r,debugLogs:i,...s}=t,o=Me({urlish:e,doAssertNoQueryParams:!0,doOutputWithTrailingSlash:!1}),n=(()=>{if(i)return $((...[u,...g])=>{const S="oidc-spa";typeof u=="string"?console.log(`${S}: ${u}`,...g):console.log(`${S}:`,u,...g)})})(),c=li({issuerUri:o,clientId:r}),{prOidcByConfigId:a}=Ge;e:{const u=a.get(c);if(u===void 0)break e;return n?.([`createOidc was called again with the same config (${JSON.stringify({issuerUri:o,clientId:r})})`,"Returning the previous instance. All potential different parameters are ignored."].join(" ")),u}const d=new X;a.set(c,d.pr);const l=await Ii(s,{issuerUri:o,clientId:r,configId:c,log:n});return d.resolve(l),l}async function Ii(t,e){{const m=window.setTimeout(()=>{console.warn(["oidc-spa: Setup error.","oidcEarlyInit() wasn't called.","This is supposed to be handled by the oidc-spa Vite plugin","or manually in other environments."].join(" "))},3e3),w=await Kt;if(window.clearTimeout(m),!w)return new Promise(()=>{})}const{transformUrlBeforeRedirect:r,extraQueryParams:i,extraTokenParams:s,decodedIdTokenSchema:o,idleSessionLifetimeInSeconds:n,autoLogoutParams:c={redirectTo:"current page"},autoLogin:a=!1,postLoginRedirectUrl:d,__unsafe_clientSecret:l,__unsafe_useIdTokenAsAccessToken:u=!1,__metadata:g,scopes:S=["openid","profile"],sessionRestorationMethod:f=t.autoLogin===!0?"full page redirect":"auto"}=t,h=t.BASE_URL??t.homeUrl,{issuerUri:p,clientId:x,configId:k,log:_}=e,q=(()=>{if(i!==void 0)return typeof i!="function"?()=>i:i})(),B=(()=>{if(s!==void 0)return typeof s!="function"?()=>s:s})(),{homeUrlAndRedirectUri:N}=ki({BASE_URL_params:h});_?.(`Calling createOidc v${bi} ${JSON.stringify({issuerUri:p,clientId:x,scopes:S,validRedirectUri:N},null,2)}`);const E=Vt(),b=g??await $r({issuerUri:p}),A=(()=>{switch(f){case"auto":break;case"full page redirect":return!1;case"iframe":return!0}e:{if(b===void 0)return!1;const{authorization_endpoint:m}=b;if(y(m!==void 0,"Missing authorization_endpoint on the provided __metadata"),!!mi({url1:window.location.origin,url2:m}))break e;const T=Ct(),O=new URL(m).origin.split("//")[1];y(O!==void 0,"33921384");const P=window.location.origin.split("//")[1];let v=!1,I=!1;const W=(()=>{if(/^(?:\d{1,3}\.){3}\d{1,3}$|^\[?[A-Fa-f0-9:]+\]?$/.test(O))return I=!0,[];const M=(()=>{const C=O.split(".");return C.length>=3&&C.shift(),C.join(".")})();{const C=M.toLowerCase();if(C.includes("auth0")||C.includes("clerk")||C.includes("microsoft")||C.includes("okta")||C.includes("aws"))return v=!0,[]}const J=new URL(N).pathname;return[`myapp.${M}`,M===O?void 0:M,`${M}/${J==="/"?"dashboard":J}`].filter(C=>C!==void 0)})();return _?.(T?["Detected localhost environment.",`
When reloading while logged in, you will briefly see`,"some URL params appear in the address bar.",`
This happens because session restore via iframe is disabled,`,"the browser treats your auth server as a third party.",`
Auth server: ${O}`,`
App domain:  ${P}`,...I?[]:v?[`
You seem to be using a well-known auth provider.`,"Check your provider's docs, some allow configuring","a your custom domain at least for the authorization endpoint.",`
If configured, oidc-spa will restore sessions silently`,"and improve the user experience."]:[`
Once deployed under the same root domain as your auth server,`,"oidc-spa will use iframes to restore sessions silently.",`
Suggested deployments:`,...W.map(M=>`
   ${M}`)],`

More info:`,"https://docs.oidc-spa.dev/v/v8/resources/third-party-cookies-and-session-restoration"].join(" "):["Silent session restore via iframe is disabled.",`
Auth server: ${O}`,`App domain:  ${P}`,`
They do not share a common root domain.`,...I?[]:v?[`
You seem to be using a well-known auth provider.`,"Check if you can configure a custom auth domain.",`
If so, oidc-spa can restore sessions silently`,"and improve the user experience."]:[`
To improve the experience, here are some examples of deployment for your app:`,...W.map(M=>`
   ${M}`)],`
More info:`,"https://docs.oidc-spa.dev/v/v8/resources/third-party-cookies-and-session-restoration"].join(" ")),!1}return!0})();A||(Si(),le.current&&_?.(["More than one oidc instance can't use iframe","falling back to persisting tokens in session storage"].join(" ")));const L=b===void 0?Xt({debugMessage:"oidc-spa: Wrong assertion 43943"}):new Nr({stateUrlParamValue:E,authority:p,client_id:x,redirect_uri:N,silent_redirect_uri:N,post_logout_redirect_uri:N,response_mode:nt({issuerUri:p})?"fragment":"query",response_type:"code",scope:Array.from(new Set(["openid",...S])).join(" "),automaticSilentRenew:!1,userStore:new Ae({store:(()=>{if(A)return new et;const m=vi({storageId:k});return le.current?m.persistCurrentStateAndSubsequentChanges():le.subscribe(()=>{m.persistCurrentStateAndSubsequentChanges()}),m})()}),stateStore:new Ae({store:localStorage,prefix:Qt}),client_secret:l,metadata:b}),D=mt(),{loginOrGoToAuthServer:z}=wi({configId:k,oidcClientTsUserManager:L,transformUrlBeforeRedirect:r,getExtraQueryParams:q,getExtraTokenParams:B,homeUrl:N,evtInitializationOutcomeUserNotLoggedIn:D,log:_}),{getIsNewBrowserSession:ne}=yi({configId:k,evtInitializationOutcomeUserNotLoggedIn:D}),{completeLoginOrRefreshProcess:Z}=await pt(),j=await(async()=>{if(b===void 0)return(await Te(async()=>{const{createWellKnownOidcConfigurationEndpointUnreachableInitializationError:m}=await import("./diagnostic-DdYBy5BP.js");return{createWellKnownOidcConfigurationEndpointUnreachableInitializationError:m}},__vite__mapDeps([0,1,2,3]))).createWellKnownOidcConfigurationEndpointUnreachableInitializationError({issuerUri:p});e:{if(A||!le.current)break e;let m;try{m=await L.getUser()}catch{m=null;try{await L.removeUser()}catch{}}if(m===null)break e;return _?.("Session was restored from session storage"),{oidcClientTsUser:m,backFromAuthServer:void 0}}e:{let m;{const{authResponse:O,clearAuthResponse:P}=Gt();if(O===void 0)break e;const v=wt({stateUrlParamValue:O.state});if(v===void 0){P();break e}if(v.configId!==k)break e;y(v.context==="redirect","3229492"),P(),m={stateData:v,authResponse:O}}if(m===void 0)break e;const{stateData:w,authResponse:T}=m;switch(w.action){case"login":{_?.(`Handling login redirect auth response ${JSON.stringify({...T,...T.code===void 0?void 0:{code:T.code.slice(0,20)+"..."}},null,2)}`);const O=Ue(T);let P;try{P=await L.signinRedirectCallback(O)}catch(v){if(y(v instanceof Error,"741947"),v.message==="Failed to fetch")return(await Te(async()=>{const{createFailedToFetchTokenEndpointInitializationError:I}=await import("./diagnostic-DdYBy5BP.js");return{createFailedToFetchTokenEndpointInitializationError:I}},__vite__mapDeps([0,1,2,3]))).createFailedToFetchTokenEndpointInitializationError({clientId:x,issuerUri:p});{const I=T.error;if(I!==void 0){_?.(`The auth server responded with: ${I}, trying to restore from the http only cookie`);break e}}return v}return ci({configId:k}),{oidcClientTsUser:P,backFromAuthServer:{extraQueryParams:w.extraQueryParams,result:Object.fromEntries(Object.entries(T).map(([v,I])=>{if(!(v==="state"||v==="session_state"||v==="iss"||v==="code")&&I!==void 0)return[v,I]}).filter(v=>v!==void 0))}}}case"logout":{_?.("Handling logout redirect auth response",T);const O=Ue(T);try{await L.signoutRedirectCallback(O)}catch{}ut({configId:k,sessionId:w.sessionId}),a&&(location.reload(),await new Promise(()=>{}));return}default:y(!1)}}e:{const m=_e({configId:k});if(m==="explicitly logged out"&&!a){_?.("Skipping silent signin with iframe, the user has logged out");break e}{const{isOnline:O,prOnline:P}=ye();if(!O)if(a)_?.(["The browser is currently offline","Since autoLogin is enabled we wait until it comes back online","to continue with authentication"].join(" ")),await P;else{_?.(["The browser is not currently online so we proceed with initialization","assuming the user isn't authenticated"].join(" "));break e}}let w,T;t:{if(m==="explicitly logged out"||!A)break t;_?.("Trying to restore the auth from the http only cookie (silent signin with iframe)");const O=await gt({oidcClientTsUserManager:L,stateUrlParamValue_instance:E,configId:k,transformUrlBeforeRedirect:r,getExtraQueryParams:q,getExtraTokenParams:B,autoLogin:a,log:_});if(y(O.outcome!=="token refreshed using refresh token","876995"),O.outcome==="timeout")return(await Te(async()=>{const{createIframeTimeoutInitializationError:v}=await import("./diagnostic-DdYBy5BP.js");return{createIframeTimeoutInitializationError:v}},__vite__mapDeps([0,1,2,3]))).createIframeTimeoutInitializationError({redirectUri:N,clientId:x,issuerUri:p});y();const{authResponse:P}=O;_?.(`Silent signin auth response ${JSON.stringify(P,null,2)}`),w=P.error;try{T=await L.signinRedirectCallback(Ue(P))}catch(v){if(y(v instanceof Error,"433344"),v.message==="Failed to fetch")return(await Te(async()=>{const{createFailedToFetchTokenEndpointInitializationError:I}=await import("./diagnostic-DdYBy5BP.js");return{createFailedToFetchTokenEndpointInitializationError:I}},__vite__mapDeps([0,1,2,3]))).createFailedToFetchTokenEndpointInitializationError({clientId:x,issuerUri:p});if(w===void 0)return v}}if(T===void 0){(a||m==="logged in"&&(w===void 0||w==="interaction_required"||w==="login_required"||w==="consent_required"||w==="account_selection_required"))&&(_?.("Performing auto login with redirect"),Z(),a&&m!=="logged in"&&D.post(),await ce({prUnlock:ft()}),await z({action:"login",doForceReloadOnBfCache:!0,redirectUrl:d||(le.current?Zt()??window.location.href:Yt()),doNavigateBackToLastPublicUrlIfTheTheUserNavigateBack:!1,extraQueryParams_local:void 0,transformUrlBeforeRedirect_local:void 0,interaction:m==="explicitly logged out"?"ensure interaction":a?"directly redirect if active session show login otherwise":"ensure no interaction",preRedirectHook:()=>{ae({configId:k,state:void 0})}})),w!==void 0&&_?.([`The auth server responded with: ${w} `,w==="login_required"?"(login_required just means that there's no active session for the user)":""].join(""));break e}return _?.("Successful silent signed in"),{oidcClientTsUser:T,backFromAuthServer:void 0}}})();Z(),await ce({prUnlock:Promise.resolve()});const ee={params:{issuerUri:p,clientId:x,validRedirectUri:N}};e:{if(!(j instanceof Error)&&j!==void 0)break e;D.post(),_e({configId:k})!=="explicitly logged out"&&ae({configId:k,state:void 0});const m=(()=>{if(j instanceof Error){_?.("User not logged in and there was an initialization error");const w=j,T=w instanceof We?w:new We({isAuthServerLikelyDown:!1,messageOrCause:w});if(a)throw T;return console.error(["oidc-spa Initialization Error: ",`isAuthServerLikelyDown: ${T.isAuthServerLikelyDown}`,"",T.message].join(`
`)),$({...ee,isUserLoggedIn:!1,login:async()=>(alert("Authentication is currently unavailable. Please try again later."),new Promise(()=>{})),initializationError:T})}if(j===void 0)return _?.("User not logged in"),$({...ee,isUserLoggedIn:!1,login:async({doesCurrentHrefRequiresAuth:w,extraQueryParams:T,redirectUrl:O,transformUrlBeforeRedirect:P})=>(await ce({prUnlock:ft()}),A||_?.([" IMPORTANT DEBUG INFO:",`
We are about to redirect to your Identity Provider (IdP).`,`
If you see an 'Invalid Redirect URI' error on the IdP page, make sure you've added:`,`
${N}`,`
to the list of valid redirect URIs in your IdP configuration.`,`
If you see a 'Client not found' error make sure you've created the flowing OIDC client:`,`
${x}`].join(" ")),z({action:"login",doNavigateBackToLastPublicUrlIfTheTheUserNavigateBack:w,doForceReloadOnBfCache:!1,redirectUrl:O??d??window.location.href,extraQueryParams_local:T,transformUrlBeforeRedirect_local:P,interaction:_e({configId:k})==="explicitly logged out"?"ensure interaction":"directly redirect if active session show login otherwise",preRedirectHook:void 0})),initializationError:void 0});y(!1)})();{const{prOtherTabLogin:w}=di({configId:k});w.then(async()=>{_?.("Other tab has logged in, reloading this tab"),await ce({prUnlock:new Promise(()=>{})}),window.location.reload()})}return m}_?.("User is logged in"),y(b!==void 0,"30483403");let R=ht({oidcClientTsUser:j.oidcClientTsUser,decodedIdTokenSchema:o,__unsafe_useIdTokenAsAccessToken:u,decodedIdToken_previous:void 0,log:_});e:{if(n===void 0||R.refreshTokenExpirationTime===void 0)break e;console.warn(["oidc-spa: You've specified idleSessionLifetimeInSeconds,","but your auth server issues a refresh_token with a known expiration time.","idleSessionLifetimeInSeconds should only be used as a fallback","for auth servers that don't specify when an inactive session expires.","The auth server, not your code, is the source of truth.","See: https://docs.oidc-spa.dev/v/v8/auto-logout"].join(" "))}_e({configId:k})!==void 0&&ae({configId:k,state:void 0}),A||ae({configId:k,state:{stateDescription:"logged in",refreshTokenExpirationTime:R.refreshTokenExpirationTime,serverDateNow:R.getServerDateNow(),idleSessionLifetimeInSeconds:n}});const fe=new Set,he=new Set,{sid:te,sub:it}=R.decodedIdToken_original;y(it!==void 0,"The 'sub' claim is missing from the id token"),y(te===void 0||typeof te=="string");let st=!1,oe;const re=$({...ee,isUserLoggedIn:!0,getTokens:async()=>{st&&(await re.logout(c),y(!1)),oe===void 0&&await new Promise(m=>de(m,0)),oe!==void 0&&await oe;e:{if(R.accessTokenExpirationTime-R.getServerDateNow()>3e4||R.getServerDateNow()-R.issuedAtTime<5e3)break e;await re.renewTokens()}return R},getDecodedIdToken:()=>R.decodedIdToken,logout:async m=>{if(Ge.hasLogoutBeenCalled)return _?.("logout() has already been called, ignoring the call"),new Promise(()=>{});Ge.hasLogoutBeenCalled=!0;const w=(()=>{switch(m.redirectTo){case"current page":return window.location.href;case"home":return N;case"specific url":return Me({urlish:m.url,doAssertNoQueryParams:!1})}})().slice(window.location.origin.length);if(await ce({prUnlock:new Promise(()=>{})}),!b.end_session_endpoint){_?.("No end session endpoint, managing logging state locally"),ae({configId:k,state:{stateDescription:"explicitly logged out"}});try{await L.removeUser()}catch{}return ut({configId:k,sessionId:te}),window.location.href=w,new Promise(()=>{})}_?.([" IMPORTANT DEBUG INFO:",`
We are about to redirect to your Identity Provider (IdP).`,`
If you see an 'Invalid Redirect URI' error on the IdP page, make sure you've added:`,`
${N}`,`
to the list of valid post logout redirect URIs in your IdP configuration.`].join(" ")),window.addEventListener("pageshow",T=>{T.persisted&&location.reload()});try{await L.signoutRedirect({state:$({configId:k,context:"redirect",rootRelativeRedirectUrl:w,action:"logout",sessionId:te}),redirectMethod:"assign"})}catch(T){y(!1,`signoutRedirect() is not expected to throw but it did: ${String(T)}`)}return new Promise(()=>{})},renewTokens:(()=>{async function m(P){const{extraTokenParams:v}=P,I=async()=>{ae({configId:k,state:void 0}),await ce({prUnlock:new Promise(()=>{})}),await z({action:"login",redirectUrl:window.location.href,doForceReloadOnBfCache:!0,extraQueryParams_local:void 0,transformUrlBeforeRedirect_local:void 0,doNavigateBackToLastPublicUrlIfTheTheUserNavigateBack:!1,interaction:"directly redirect if active session show login otherwise",preRedirectHook:void 0}),y(!1,"136134")};!R.hasRefreshToken&&!A&&(_?.(["Unable to refresh tokens without a full app reload,","because no refresh token is available","and your app setup prevents silent sign-in via iframe.","Your only option to refresh tokens is to call `window.location.reload()`"].join(" ")),await I(),y(!1,"136135")),_?.("Renewing tokens");const{completeLoginOrRefreshProcess:W}=await pt(),M=await gt({oidcClientTsUserManager:L,stateUrlParamValue_instance:E,configId:k,transformUrlBeforeRedirect:r,getExtraQueryParams:q,getExtraTokenParams:()=>v,autoLogin:a,log:_});M.outcome==="timeout"&&(_?.(["Silent refresh of the token failed the iframe didn't post a response (timeout).","This isn't recoverable, reloading the page."].join(" ")),window.location.reload(),await new Promise(()=>{}),y(!1));let J;switch(M.outcome){case"token refreshed using refresh token":_?.("Refresh token used"),J=M.oidcClientTsUser;break;case"got auth response from iframe":{const{authResponse:C}=M;_?.("Tokens refresh using iframe",C);const pe=C.error;let ke;try{ke=await L.signinRedirectCallback(Ue(C))}catch(be){if(y(be instanceof Error,"321389"),pe===void 0)throw W(),be}ke===void 0&&(W(),_?.(["The user is probably not logged in anymore,","need to redirect to login pages"].join(" ")),await I(),y(!1,"136135")),J=ke}break;default:y(!1);break}R=ht({oidcClientTsUser:J,decodedIdTokenSchema:o,__unsafe_useIdTokenAsAccessToken:u,decodedIdToken_previous:R.decodedIdToken,log:_}),_e({configId:k})!==void 0&&ae({configId:k,state:{stateDescription:"logged in",refreshTokenExpirationTime:R.refreshTokenExpirationTime,serverDateNow:R.getServerDateNow(),idleSessionLifetimeInSeconds:n}}),Array.from(he).forEach(C=>C(R)),W()}let w;function T(){y(w!==void 0,"131276");const{pr:P}=w;P.then(()=>{y(w!==void 0,"549462"),w.pr===P&&(w=void 0)})}async function O(P){const{extraTokenParams:v}=P,I={...B?.(),...v};return w===void 0?(w={pr:m({extraTokenParams:I}),extraTokenParams:I},T(),w.pr):(JSON.stringify(I)===JSON.stringify(w.extraTokenParams)||(w={pr:(async()=>(await w.pr,m({extraTokenParams:I})))(),extraTokenParams:I},T()),w.pr)}return P=>{const{extraTokenParams:v}=P??{};return oe=O({extraTokenParams:v}),oe.then(()=>{oe=void 0}),oe}})(),subscribeToTokensChange:m=>(he.add(m),{unsubscribe:()=>{he.delete(m)}}),subscribeToAutoLogoutCountdown:m=>(fe.add(m),{unsubscribeFromAutoLogoutCountdown:()=>{fe.delete(m)}}),goToAuthServer:({extraQueryParams:m,redirectUrl:w,transformUrlBeforeRedirect:T})=>z({action:"go to auth server",redirectUrl:w??window.location.href,extraQueryParams_local:m,transformUrlBeforeRedirect_local:T}),backFromAuthServer:j.backFromAuthServer,isNewBrowserSession:(()=>{const m=ne({subjectId:it});return _?.(`isNewBrowserSession: ${m}`),m})()});{const{prOtherTabLogout:m}=ai({configId:k,sessionId:te});m.then(async()=>{_?.("Other tab has logged out, refreshing current tab"),await ce({prUnlock:new Promise(()=>{})}),location.reload()})}(function m(){if(!R.hasRefreshToken&&!A)return;let w;const T=5e3;(async()=>{for(;;){const P=Date.now();await new Promise(M=>{w=de(M,T)});const I=Date.now()-P;if(Math.abs(I-T)>1e3){_?.("Renewing token now as local time might have shifted"),re.renewTokens();return}}})();const{unsubscribe:O}=re.subscribeToTokensChange(()=>{w!==void 0&&Le(w),O(),m()})})(),(function m(){if(!R.hasRefreshToken&&!A){_?.(["Session keep-alive disabled: no refresh token and no iframe support. ","Result: once tokens expire, continuing requires full reload."].join(" "));return}const w=n===void 0?void 0:n*1e3,T=R.refreshTokenExpirationTime===void 0?void 0:R.refreshTokenExpirationTime-R.getServerDateNow(),O=R.accessTokenExpirationTime-R.getServerDateNow();let P=!1;if(R.refreshTokenExpirationTime!==void 0&&R.refreshTokenExpirationTime>=se){const C=[];if(S.includes("offline_access")?C.push("offline_access scope was explicitly requested."):nt({issuerUri:p})&&C.push("Keycloak likely enabled offline_access by default."),C.length>0){C.push("Misconfiguration: offline_access is for native apps, not for web apps like yours. ","You lose SSO and users must log in after every reload."),console.warn(`oidc-spa: ${C.join(" ")}`);return}P=!0}const v=3e4,I=v+15e3;e:{if(T===void 0||T>I)break e;console.warn(["oidc-spa: The session is nearing its maximum lifetime, and the user will soon need to log in again,",`or you've configured a refresh_token with a TTL of ${H(T)}.`,`If it's the latter, the TTL is too short, it must be at least ${H(I)} for reliable operation.`,"Shorter lifetimes can cause unpredictable session expirations and are usually a misconfiguration.",`
In either case, oidc-spa will not ping the auth server to keep the session alive.`].join(" "));return}let W=(()=>{if(T!==void 0&&!P)return _?.([H(T),"before expiration of the refresh_token.",`Scheduling renewal of the tokens ${H(v)} before expiration as a way to keep the session alive on the OIDC server.`].join(" ")),T;if(w!==void 0){if(w<I)throw new Error([`oidc-spa: The configured idleSessionLifetimeInSeconds (${H(w)}) is too short.`,`For reliability, it must be at least ${H(I)}.`,"Very short session idle lifetimes are usually a misconfiguration, even for ultra sensitive apps."].join(" "));return _?.([`You've set idleSessionLifetimeInSeconds to ${H(w)}.`,`This means the user session will expire after ${H(w)} of inactivity (assuming you're right).`,`Scheduling token renewal ${H(v)} before expiration to keep the session active on the OIDC server.`].join(" ")),w}const C=O>I?O:36e5;return _?.(["The auth server's idle session timeout is unknown.",P&&"(The refresh token never expires)",`Assuming a default idle session TTL of ${H(C)}.`,`Scheduling token renewal ${H(v)} before expiration to keep the session active on the OIDC server.`].filter(pe=>typeof pe=="string").join(" ")),C})();const M=de(async()=>{{const{isOnline:C,prOnline:pe}=ye();if(!C&&!await Promise.race([new Promise(be=>de(()=>be(!1),v-1e3)),pe.then(()=>!0)])){_?.(["The session expired on the OIDC server.","We couldn't keep it alive because the browser was offline.","We are not redirecting to the login page to support PWAs with offline features.","However, the next getTokens() call will trigger a redirect to the Auth server login page."].join(" "));return}}_?.(`Renewing the tokens now as otherwise the session will be terminated by the auth server in ${H(v)}`),await re.renewTokens()},Math.min(W-v,Math.pow(2,31)-1)),{unsubscribe:J}=re.subscribeToTokensChange(()=>{Le(M),J(),m()})})();e:{const m=()=>{if(R.refreshTokenExpirationTime===void 0)return n;if(R.refreshTokenExpirationTime>=se)return n??0;const v=(R.refreshTokenExpirationTime-R.issuedAtTime)/1e3;return n!==void 0?Math.min(n,v):v};if(m()===0){_?.("The refresh_token never expires, disabling auto logout mechanism.");break e}if(m()===void 0){_?.(`${R.hasRefreshToken?"The refresh token is opaque, we can't read it's expiration time":"No refresh token"}, and idleSessionLifetimeInSeconds was not set, can't implement auto logout mechanism.`);break e}const{startCountdown:w}=oi({tickCallback:async({secondsLeft:v})=>{const I=W=>{const{secondsLeft:M}=W;Array.from(fe).forEach(J=>J({secondsLeft:M}))};if(v===0){t:{const{isOnline:W,prOnline:M}=ye();if(W||await Promise.race([new Promise(C=>de(()=>C(!1),1e4)),M.then(()=>!0)]))break t;_?.(["Normally now we should auto logout.","However since the browser is currently offline","we avoid calling logout() now to play nice in case","this app is a PWA.","Next getTokens() is called logout will be called"].join(" ")),P(),I({secondsLeft:void 0}),st=!0;return}await re.logout(c)}I({secondsLeft:v})}});let T;const O=ni({configId:k,sessionId:te}),{unsubscribe:P}=O.subscribe(v=>{if(v)T!==void 0&&(T(),T=void 0);else{y(T===void 0,"902992");const I=m();y(I!==void 0,"902992326"),T=w({countDownFromSeconds:I}).stopCountdown}});{const v=m();y(v!==void 0,"9029923253"),_?.([`The user will be automatically logged out after ${H(v*1e3)} of inactivity.`,n===void 0?void 0:"It was artificially defined by using the idleSessionLifetimeInSeconds param."].filter(I=>I!==void 0).join(`
`))}}return re}const xi=Object.freeze(Object.defineProperty({__proto__:null,OidcInitializationError:We,createOidc:Ti},Symbol.toStringTag,{value:"Module"}));export{Lr as W,xi as i};
